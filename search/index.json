[{"content":"本文描述了黑马springcloud项目学成在线的媒资管理模块的搭建\n模块需求分析 模块介绍 媒资管理系统是每个在线教育平台所必须具备的，查阅百度百科对它的定义如下： 媒体资源管理(Media Asset Management，MAM)系统是建立在多媒体、网络、数据库和数字存储等先进技术基础上的一个对各种媒体及内容(如视/音频资料、文本文件、图表等)进行数字化存储、管理以及应用的总体解决方案，包括数字媒体的采集、编目、管理、传输和编码转换等所有环节。其主要是满足媒体资源拥有者收集、保存、查找、编辑、发布各种信息的要求，为媒体资源的使用者提供访问内容的便捷方法，实现对媒体资源的高效管理，大幅度提高媒体资源的价值。\n每个教学机构都可以在媒资系统管理自己的教学资源，包括：视频、教案等文件。\n目前媒资管理的主要管理对象是视频、图片、文档等，包括：媒资文件的查询、文件上传、视频处理等。\n主要的功能如下：\n媒资查询：教学机构查询自己所拥有的媒资信息。 文件上传：包括上传图片、上传文档、上传视频。 视频处理：视频上传成功，系统自动对视频进行编码处理。 文件删除：教学机构删除自己上传的媒资文件。 下图是课程编辑与发布的整体流程，通过下图可以看到媒资管理在整体流程的位置：\n业务流程 上传图片 教学机构人员在课程信息编辑页面上传课程图片，课程图片统一记录在媒资管理系统。 上传视频 教学机构人员进入媒资管理列表查询自己上传的媒资文件。点击“媒资管理”，进入媒资管理列表页面查询本机构上传的媒资文件。 教育机构用户在\u0026quot;媒资管理\u0026quot;页面中点击 \u0026ldquo;上传视频\u0026rdquo; 按钮。点击“上传视频”打开上传页面。 选择要上传的文件，自动执行文件上传，视频上传成功会自动处理。 处理视频 对需要转码处理的视频系统会自动对其处理，处理后生成视频的URL。 处理视频没有用户界面，完全是后台自动执行。 审核媒资 审核媒资包括程序自动审核和人工审核，程序可以通过鉴黄接口https://www.aliyun.com/product/lvwang?spm=5176.19720258.J_3207526240.51.e93976f4rSq796审核视频，对有异议的视频由人工进行审核。 执行步骤 运营用户登入运营平台并进入媒资管理页面，查找待审核媒资 点击列表中媒资名称链接，可预览该媒资，若是视频，则播放视频。 点击列表中某媒资后的\u0026quot;审核\u0026quot; 按钮，开始审核。 选择审核结果，输入审核意见，完成媒资的审批过程。 绑定媒资 课程计划创建好后需要绑定媒资文件，比如：如果课程计划绑定了视频文件，进入课程在线学习界面后，点课程计划名称则在线播放视频。 如何将课程计划绑定媒资呢？ 教育机构用户进入课程管理页面并编辑某一个课程，在\u0026quot;课程大纲\u0026quot;标签页的某一小节后可点击”添加视频“。 弹出添加视频对话框，可通过视频关键字搜索已审核通过的视频媒资。 数据模型 本模块媒资文件相关的数据表如下：\n媒资文件表 待处理视频表 视频处理历史表 媒资文件与课程计划绑定关系表如下：\n搭建模块环境 架构的问题分析 当前要开发的是媒资管理服务，目前为止共三个微服务：内容管理、系统管理、媒资管理，如下图： 后期还会添加更多的微服务，当前这种由前端直接请求微服务的方式存在弊端：\n如果在前端对每个请求地址都配置绝对路径，非常不利于系统维护，比如下边代码中请求系统管理服务的地址使用的是localhost 当系统上线后这里需要改成公网的域名，如果这种地址非常多则非常麻烦。 基于这个问题可以采用网关来解决，如下图： 这样在前端的代码中只需要指定每个接口的相对路径，如下所示： 在前端代码的一个固定的地方在接口地址前统一加网关的地址，每个请求统一到网关，由网关将请求转发到具体的微服务。 为什么所有的请求先到网关呢？\n有了网关就可以对请求进行路由，路由到具体的微服务，减少外界对接微服务的成本，比如：400电话，路由则可以根据请求路径进行路由、根据host地址进行路由等， 当微服务有多个实例时可以通过负载均衡算法进行路由，如下： 另外，网关还可以实现权限控制、限流等功能。 项目采用Spring Cloud Gateway作为网关，网关在请求路由时需要知道每个微服务实例的地址，项目使用Nacos作用服务发现中心和配置中心，整体的架构图如下：\n流程如下：\n微服务启动，将自己注册到Nacos，Nacos记录了各微服务实例的地址。 网关从Nacos读取服务列表，包括服务名称、服务地址等。 请求到达网关，网关将请求路由到具体的微服务。 要使用网关首先搭建Nacos，Nacos有两个作用：\n服务发现中心。\n微服务将自身注册至Nacos，网关从Nacos获取微服务列表。 配置中心。\n微服务众多，它们的配置信息也非常复杂，为了提供系统的可维护性，微服务的配置信息统一在Nacos配置。 搭建Nacos 服务发现中心 运行Nacos\n使用课程提供的Nacos，一般我们启动课程资料给我们的虚拟机时，Nacos会自动执行，但是Nacos需要Mysql作为数据库，故Nacos必须在Mysql之后运行，单Mysql一般不会随虚拟机启动而启动，所以我们需要在启动Mysql后，在重启以下Nacos，保证不出错。 启动Nacos后，访问Nacos页面：虚拟机ip地址+8848/nacos，使用课程资料中的虚拟机的访问http://192.168.101.65:8848/nacos/即可。 账号：nacos，密码：nacos 在搭建Nacos服务发现中心之前需要搞清楚两个概念：namespace和group\nnamespace：用于区分环境、比如：开发环境、测试环境、生产环境。\ngroup：用于区分项目，比如：xuecheng-plus项目、xuecheng2.0项目\n首先在nacos配置namespace:\n点击左侧菜单“命名空间”进入命名空间管理界面 点击“新建命名空间”，填写命名空间的相关信息，如下图 使用相同的办法再创建“测试环境”、\u0026ldquo;生产环境\u0026quot;的命名空间。\n创建成功，如下图：\n[!CAUTION]\n注意：如果使用dev1010命名空间，在下边的配置中对namespace配置为dev1010。\n命名空间创建完毕后，首先完成各服务注册到Naocs，下边将内容管理服务注册到nacos中。\n在xuecheng-plus-parent中添加依赖管理\n1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 在内容管理模块的接口工程、系统管理模块的接口工程中添加如下依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置nacos的地址\n在系统管理的接口工程的配置文件中配置如下信息： 1 2 3 4 5 6 7 8 9 10 #微服务配置 spring: application: name: system-service cloud: nacos: server-addr: 192.168.101.65:8848 discovery: namespace: dev group: xuecheng-plus-project 在内容管理的接口工程的配置文件中配置如下信息： 1 2 3 4 5 6 7 8 9 10 #微服务配置 spring: application: name: content-api cloud: nacos: server-addr: 192.168.101.65:8848 discovery: namespace: dev group: xuecheng-plus-project 重启内容管理服务、系统管理服务。\n待微服务启动成功，进入Nacos服务查看服务列表 在 “开发环境” 命名空间下有两个服务这说明内容管理微服务和系统管理微服务在Nacos注册成功。 配置中心 配置三要素 搭建完成Nacos服务发现中心，下边搭建Nacos为配置中心，其目的就是通过Nacos去管理项目的所有配置。\n先将项目中的配置文件分分类：\n每个项目特有的配置\n是指该配置只在有些项目中需要配置，或者该配置在每个项目中配置的值不同。\n比如：spring.application.name每个项目都需要配置但值不一样，以及有些项目需要连接数据库而有些项目不需要，有些项目需要配置消息队列而有些项目不需要。\n项目所公用的配置\n是指在若干项目中配置内容相同的配置。比如：redis的配置，很多项目用的同一套redis服务所以配置也一样。\n另外还需要知道nacos如何去定位一个具体的配置文件，即：namespace、group、dataid.\n定位配置文件\n通过namespace、group找到具体的环境和具体的项目。\n通过dataid找到具体的配置文件，dataid有三部分组成\n比如：content-service-dev.yaml配置文件 由（content-service）-（dev）. (yaml)三部分组成\ncontent-service：第一部分，它是在application.yaml中配置的应用名，即spring.application.name的值。\ndev：第二部分，它是环境名，通过spring.profiles.active指定，\nYaml: 第三部分，它是配置文件 的后缀，目前nacos支持properties、yaml等格式类型，本项目选择yaml格式类型。\n所以，如果我们要配置content-service工程的配置文件:\n在开发环境中配置content-service-dev.yaml\n在测试环境中配置content-service-test.yaml\n在生产环境中配置content-service-prod.yaml\n我们启动项目中传入spring.profiles.active的参数决定引用哪个环境的配置文件，例如：传入spring.profiles.active=dev表示使用dev环境的配置文件即content-service-dev.yaml。\n配置content-service 下边以开发环境为例对content-service工程的配置文件进行配置，再开发环境命名空间中，添加content-service-dev.yaml配置 输入data id、group以及配置文件内容。\n为什么没在nacos中配置下边的内容 ？\n1 2 3 spring: application: name: content-service 因为刚才说了dataid第一部分就是spring.application.name，再根据${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}作为文件id，来读取配置。\n而读取配置文件的顺序如下\nbootstrap.yml nacos中的配置文件 本地application.yml 所以spring.application.name不在nacos中配置，而是要在工程的本地(bootstrap.yaml)进行配置，然后nacos才知道怎么读取配置文件。\n在content-service工程的test/resources 中添加bootstrap.yaml，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 spring: application: name: content-service cloud: nacos: server-addr: 192.168.101.65:8848 discovery: namespace: dev group: xuecheng-plus-project config: namespace: dev group: xuecheng-plus-project file-extension: yaml refresh-enabled: true #profiles默认为dev profiles: active: dev 在内容管理模块的接口工程和service工程配置依赖： 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 配置完成，运行content-service工程 的单元测试文件，能否正常测试，跟踪单元测试方法可以正常读取数据库的数据，说明从nacos读取配置信息正常。\n通过运行观察控制台打印出下边的信息，NacosRestTemplate.java通过Post方式与nacos服务端交互读取配置信息。\n1 [NacosRestTemplate.java:476] - HTTP method: POST, url: http://192.168.101.65:8848/nacos/v1/cs/configs/listener, body: {Listening-Configs=content-service.yamlxuecheng-plus-projectdevcontent-service-dev.yamlxuecheng-plus-project88459b1483b8381eccc2ef462bd59182devcontent-servicexuecheng-plus-projectdev, tenant=dev} 配置content-api 以相同的方法配置content-api工程的配置文件，在nacos中的开发环境中配置content-api-dev.yaml，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 server: servlet: context-path: /content port: 63040 # 日志文件配置路径 logging: config: classpath:log4j2-dev.xml # swagger 文档配置 swagger: title: \u0026#34;学成在线内容管理系统\u0026#34; description: \u0026#34;内容系统管理系统对课程相关信息进行业务管理数据\u0026#34; base-package: com.xuecheng.content enabled: true version: 1.0.0 在content-api工程的本地配置bootstrap.yaml，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #微服务配置 spring: application: name: content-api cloud: nacos: server-addr: 192.168.101.65:8848 discovery: namespace: dev group: xuecheng-plus-project config: namespace: dev group: xuecheng-plus-project file-extension: yaml refresh-enabled: true extension-configs: - data-id: content-service-${spring.profiles.active}.yaml group: xuecheng-plus-project refresh: true profiles: active: dev 注意：因为api接口工程依赖了service工程的jar，所以这里使用extension-configs扩展配置文件的方式引用service工程所用到的配置文件。 1 2 3 4 extension-configs: - data-id: content-service-${spring.profiles.active}.yaml group: xuecheng-plus-project refresh: true 如果添加多个扩展文件，继续在下添加即可，如下： 1 2 3 4 5 6 7 extension-configs: - data-id: content-service-${spring.profiles.active}.yaml group: xuecheng-plus-project refresh: true - data-id: 填写文件 dataid group: xuecheng-plus-project refresh: true 启动content-api工程，查询控制台是否打印出了请求nacos的日志，如下: 1 [NacosRestTemplate.java:476] - HTTP method: POST, url: http://192.168.101.65:8848/nacos/v1/cs/configs/listener 使用Httpclient测试课程查询接口是否可以正常查询。 公用配置 还有一个优化的点是如何在nacos中配置项目的公用配置呢？\nnacos提供了shared-configs可以引入公用配置。\n在content-api中配置了swagger，所有的接口工程 都需要配置swagger，这里就可以将swagger的配置定义为一个公用配置，哪个项目用引入即可。\n单独在xuecheng-plus-common分组下创建xuecheng-plus的公用配置，进入nacos的开发环境，添加swagger-dev.yaml公用配置\n删除接口工程中对swagger的配置。 项目使用shared-configs可以引入公用配置。在接口工程的本地配置文件 中引入公用配置，如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 spring: application: name: content-api cloud: nacos: server-addr: 192.168.101.65:8848 discovery: namespace: dev group: xuecheng-plus-project config: namespace: dev group: xuecheng-plus-project file-extension: yaml refresh-enabled: true extension-configs: - data-id: content-service-${spring.profiles.active}.yaml group: xuecheng-plus-project refresh: true shared-configs: - data-id: swagger-${spring.profiles.active}.yaml group: xuecheng-plus-common refresh: true - data-id: logging-${spring.profiles.active}.yaml group: xuecheng-plus-common refresh: true profiles: active: dev 再以相同的方法配置日志的公用配置。 在接口工程和业务工程，引入loggin-dev.yaml公用配置文件 1 2 3 - data-id: logging-${spring.profiles.active}.yaml group: xuecheng-plus-common refresh: true 配置完成，重启content-api接口工程，访问]http://localhost:63040/content/swagger-ui.html 查看swagger接口文档是否可以正常访问，查看控制台log4j2日志输出是否正常。\n配置优先级 到目前为止已将所有微服务的配置统一在nacos进行配置，用到的配置文件有本地的配置文件 bootstrap.yaml和nacos上的配置文件，SpringBoot读取配置文件的顺序如下： 加在bootstarp.yaml，获取nacos地址、配置文件dataidid 根据dataid读取nacos中的配置 加在本地配置(例如application.yaml/application-dev.yaml)，与nacos拉取的配置合并 引入配置文件的形式有：\n以项目应用名方式引入(bootstrap) 以扩展配置文件方式引入 以共享配置文件方式引入 本地配置文件 各配置文件的优先级：项目应用名配置文件 \u0026gt; 扩展配置文件 \u0026gt; 共享配置文件 \u0026gt; 本地配置文件。\n有时候我们在测试程序时直接在本地加一个配置进行测试，比如下边的例子：\n我们想启动两个内容管理微服务，此时需要在本地指定不同的端口，通过VM Options参数，在IDEA配置启动参数 通过-D指定参数名和参数值，参数名即在bootstrap.yml中配置的server.port。 启动ContentApplication2，发现端口仍然是63040，这说明本地的配置没有生效。 这时我们想让本地最优先，可以在nacos配置文件 中配置如下即可实现： 1 2 3 4 5 #配置本地优先 spring: cloud: config: override-none: true 再次启动ContentApplication2，端口为63041。 导入配置文件 课程资料中提供了系统用的所有配置文件nacos_config_export.zip，下边将nacos_config_export.zip导入nacos。 进入具体的命名空间，点击“导入配置” 打开导入窗口 相同的配置选择跳过配置(上图选错了)。 点击“上传文件”选择资料中的nacos_config_export.zip开始导入。 配置系统管理服务 配置system-api bootstrap中的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #微服务配置 spring: application: name: system-api cloud: nacos: server-addr: 192.168.101.65:8848 discovery: # 注册中心 namespace: dev group: xuecheng-plus-project config: # 配置中心 namespace: dev group: xuecheng-plus-project file-extension: yaml refresh-enabled: true extension-configs: - data-id: system-service-${spring.profiles.active}.yaml group: xuecheng-plus-project refresh: true shared-configs: - data-id: swagger-${spring.profiles.active}.yaml group: xuecheng-plus-common refresh: true - data-id: logging-${spring.profiles.active}.yaml group: xuecheng-plus-common refresh: true profiles: active: dev nacos中的内容已经导入不要配置，即dataid为：system-api-dev.yaml的配置\n配置system-service service项目中没有用到配置无需添加 nacos中的内容已经导入不要配置，即dataid为：system-service-dev.yaml的配置 搭建Gateway 本项目使用Spring Cloud Gateway作为网关，下边创建网关工程。\n新建一个网关工程。\n工程结构 添加依赖： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../xuecheng-plus-parent\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--网关--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--服务发现中心--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 排除 Spring Boot 依赖的日志包冲突 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot 集成 log4j2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 配置网关的bootstrap.yaml配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #微服务配置 spring: application: name: gateway cloud: nacos: server-addr: 192.168.101.65:8848 discovery: namespace: dev group: xuecheng-plus-project config: namespace: dev group: xuecheng-plus-project file-extension: yaml refresh-enabled: true shared-configs: - data-id: logging-${spring.profiles.active}.yaml group: xuecheng-plus-common refresh: true profiles: active: dev 在nacos上配置网关策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 server: port: 63010 # 网关端口 spring: cloud: gateway: # filter: # strip-prefix: # enabled: true routes: # 网关路由配置 - id: content-api # 路由id，自定义，只要唯一即可 # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址 uri: lb://content-api # 路由的目标地址 lb就是负载均衡，后面跟服务名称 predicates: # 路由断言，也就是判断请求是否符合路由规则的条件 - Path=/content/** # 这个是按照路径匹配，只要以/content/开头就符合要求 # filters: # - StripPrefix=1 - id: system-api # uri: http://127.0.0.1:8081 uri: lb://system-api predicates: - Path=/system/** # filters: # - StripPrefix=1 - id: media-api # uri: http://127.0.0.1:8081 uri: lb://media-api predicates: - Path=/media/** # filters: # - StripPrefix=1 启动网关工程，通过网关工程访问微服务进行测试。 在http-client-env.json中配置网关的地址 使用httpclient测试课程查询接口，如下： 1 2 3 4 5 6 7 8 ### 课程查询列表 POST {{gateway_host}}/content/course/list?pageNo=2\u0026amp;pageSize=1 Content-Type: application/json { \u0026#34;auditStatus\u0026#34;: \u0026#34;202002\u0026#34;, \u0026#34;courseName\u0026#34;: \u0026#34;\u0026#34; } 运行，观察是否可以正常访问接口 网关工程搭建完成即可将前端工程中的接口地址改为网关的地址 搭建媒资工程 至此网关、Nacos已经搭建完成，下边将媒资工程导入项目。\n从黑马提供的课程资料中获取媒资工程 xuecheng-plus-media，拷贝到项目工程根目录。\n下边做如下配置：\n创建媒资数据库xc_media，并导入资料目录中的xcplus_media.sql 修改nacos上的media-service-dev.yaml配置文件中的数据库链接信息 重启media-api工程只要能正常启动成功即可，稍后根据需求写接口。 分布式文件系统 什么是分布式文件系统 要理解分布式文件系统首先了解什么是文件系统。 查阅维基百科： 计算机的文件系统是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和树形目录的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的那个块地址没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。\n文件系统是负责管理和存储文件的系统软件，操作系统通过文件系统提供的接口去存取文件，用户通过操作系统访问磁盘上的文件。 下图指示了文件系统所处的位置： 常见的文件系统：FAT16/FAT32、NTFS、HFS、UFS、APFS、XFS、Ext4等 。\n现在有个问题，一此短视频平台拥有大量的视频、图片，这些视频文件、图片文件该如何存储呢？如何存储可以满足互联网上海量用户的浏览。\n分布式文件系统就是海量用户查阅海量文件的方案。\n我们阅读维基百科去理解分布式文件系统的定义：\n相对于本机端的文件系统而言，分布式文件系统（英语：Distributed file system, DFS），或是网络文件系统（英语：Network File System），是一种允许文件透过网络在多台主机上分享的文件系统，可让多机器上的多用户分享文件和存储空间。\n通过概念可以简单理解为：一个计算机无法存储海量的文件，通过网络将若干计算机组织起来共同去存储海量的文件，去接收海量用户的请求，这些组织起来的计算机通过网络进行通信，如下图： 好处：\n一台计算机的文件系统处理能力扩充到多台计算机同时处理。 一台计算机挂了还有另外副本计算机提供数据。 每台计算机可以放在不同的地域，这样用户就可以就近访问，提高访问速度。 市面上有哪些分布式文件系统的产品呢？\nNFS 网络文件系统（英语：Network File System，缩写作 NFS）是一种分布式文件系统，力求客户端主机可以访问服务器端文件，并且其过程与访问本地存储时一样，它由Sun微系统（已被甲骨文公司收购）开发，于1984年发布[1]。\n它基于开放网络运算远程过程调用（ONC RPC）系统：一个开放、标准的RFC系统，任何人或组织都可以依据标准实现它。\n特点： 在客户端上映射NFS服务器的驱动器。 客户端通过网络访问NFS服务器的硬盘完全透明。 GFS Google文件系统（英语：Google File System，缩写为GFS或GoogleFS），一种专有分布式文件系统，由Google公司开发，运行于Linux平台上[1]。尽管Google在2003年公布了该系统的一些技术细节，但Google并没有将该系统的软件部分作为开源软件发布[2]。\n特点： GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver组成。 master存储了数据文件的元数据，一个文件被分成了若干块存储在多个chunkserver中。 用户从master中获取数据元信息，向chunkserver存储数据。 HDFS HDFS，是Hadoop Distributed File System的简称，是Hadoop抽象文件系统的一种实现。HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。 HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。\n特点 HDFS采用主从结构，一个HDFS集群由一个名称结点和若干数据结点组成。 名称结点存储数据的元信息，一个完整的数据文件分成若干块存储在数据结点。 客户端从名称结点获取数据的元信息及数据分块的信息，得到信息客户端即可从数据块来存取数据。 云计算厂家\n阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。其数据设计持久性不低于 99.9999999999%（12 个 9），服务设计可用性（或业务连续性）不低于 99.995%。 官方网站：https://www.aliyun.com/product/oss\n百度对象存储BOS提供稳定、安全、高效、高可扩展的云存储服务。您可以将任意数量和形式的非结构化数据存入BOS，并对数据进行管理和处理。BOS支持标准、低频、冷和归档存储等多种存储类型，满足多场景的存储需求。 官方网站：https://cloud.baidu.com/product/bos.html\nMinIo 介绍 本项目采用MinIO构建分布式文件系统，MinIO 是一个非常轻量的服务,可以很简单的和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等。\n它一大特点就是轻量，使用简单，功能强大，支持各种平台，单个文件最大5TB，兼容 Amazon S3接口，提供了 Java、Python、GO等多版本SDK支持。\n官网：https://min.io\n中文：https://www.minio.org.cn/，http://docs.minio.org.cn/docs/\nMinIO集群采用去中心化共享架构，每个结点是对等关系，通过Nginx可对MinIO进行负载均衡访问。\n去中心化有什么好处？\n在大数据领域，通常的设计理念都是无中心和分布式。Minio分布式模式可以帮助你搭建一个高可用的对象存储服务，你可以使用这些存储设备，而不用考虑其真实物理位置。\n它将分布在不同服务器上的多块硬盘组成一个对象存储服务。由于硬盘分布在不同的节点上，分布式Minio避免了单点故障。如下图：\nMinio使用纠删码技术来保护数据，它是一种恢复丢失和损坏数据的数学算法，它将数据分块冗余的分散存储在各各节点的磁盘上，所有的可用磁盘组成一个集合，上图由8块硬盘组成一个集合，当上传一个文件时会通过纠删码算法计算对文件进行分块存储，除了将文件本身分成4个数据块，还会生成4个校验块，数据块和校验块会分散的存储在这8块硬盘上。\n使用纠删码的好处是即便丢失一半数量（N/2）的硬盘，仍然可以恢复数据。 比如上边集合中有4个以内的硬盘损害仍可保证数据恢复，不影响上传和下载，如果多于一半的硬盘坏了则无法恢复。\n测试Docker环境 开发阶段和生产阶段统一使用Docker下的MINIO。\n在下发的虚拟机中已安装了MinIO的镜像和容器，执行docker start minio(或者sh /data/soft /restart.sh)启动Docker下的MinIO\n启动完成登录MinIO查看是否正常。\n访问http://192.168.101.65:9000\n本项目创建两个buckets(点击 create bucket 即可)：\nmediafiles： 普通文件\nvideo：视频文件\n[!CAUTION]\n注意：\n为bucket取名时，不能用大写字母 创建完bucket后，点击manage，进去修改访问权限为public SDK 上传文件 MinIO提供多个语言版本SDK的支持，下边找到java版本的文档：\n地址：https://docs.min.io/docs/java-client-quickstart-guide.html\n最低需求Java 1.8或更高版本:\nmaven依赖如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.minio\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;minio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.4.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.squareup.okhttp3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.8.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在media-service工程添加此依赖。\n参数说明：\n需要三个参数才能连接到minio服务。\n参数 说明 Endpoint 对象存储服务的URL Access Key Access key就像用户ID，可以唯一标识你的账户。 Secret Key Secret key是你账户的密码。 官方的示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import io.minio.BucketExistsArgs; import io.minio.MakeBucketArgs; import io.minio.MinioClient; import io.minio.UploadObjectArgs; import io.minio.errors.MinioException; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; public class FileUploader { public static void main(String[] args)throws IOException, NoSuchAlgorithmException, InvalidKeyException { try { // Create a minioClient with the MinIO server playground, its access key and secret key. // 创建MinIO客户端，连接参数就是上述表格中的三个参数，192.168.101.65:9000、minioadmin、minioadmin MinioClient minioClient = MinioClient.builder() .endpoint(\u0026#34;https://play.min.io\u0026#34;) .credentials(\u0026#34;Q3AM3UQ867SPQQA43P2F\u0026#34;, \u0026#34;zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\u0026#34;) .build(); // Make \u0026#39;asiatrip\u0026#39; bucket if not exist. // 该步骤为创建bucket，但是我们已经在minio的可视化界面创建完毕，故无需再创建 boolean found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(\u0026#34;asiatrip\u0026#34;).build()); if (!found) { // Make a new bucket called \u0026#39;asiatrip\u0026#39;. minioClient.makeBucket(MakeBucketArgs.builder().bucket(\u0026#34;asiatrip\u0026#34;).build()); } else { System.out.println(\u0026#34;Bucket \u0026#39;asiatrip\u0026#39; already exists.\u0026#34;); } // Upload \u0026#39;/home/user/Photos/asiaphotos.zip\u0026#39; as object name \u0026#39;asiaphotos-2015.zip\u0026#39; to bucket // \u0026#39;asiatrip\u0026#39;. // 将 \u0026#39;/home/user/Photos/asiaphotos.zip\u0026#39; 文件命名为 \u0026#39;asiaphotos-2015.zip\u0026#39; // 并上传到 \u0026#39;asiatrip\u0026#39; 里（示例代码创建的bucket） minioClient.uploadObject( UploadObjectArgs.builder() .bucket(\u0026#34;asiatrip\u0026#34;) .object(\u0026#34;asiaphotos-2015.zip\u0026#34;) .filename(\u0026#34;/home/user/Photos/asiaphotos.zip\u0026#34;) .build()); // 这段输出也没有用，可以直接删掉 System.out.println( \u0026#34;\u0026#39;/home/user/Photos/asiaphotos.zip\u0026#39; is successfully uploaded as \u0026#34; + \u0026#34;object \u0026#39;asiaphotos-2015.zip\u0026#39; to bucket \u0026#39;asiatrip\u0026#39;.\u0026#34;); } catch (MinioException e) { System.out.println(\u0026#34;Error occurred: \u0026#34; + e); System.out.println(\u0026#34;HTTP trace: \u0026#34; + e.httpTrace()); } } } 参考示例在media-service工程中测试上传文件功能， 首先创建一个用于测试的bucket(testbucket)，修改访问权限为public 在xuecheng-plus-media-service工程 的test下编写测试代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.xuecheng.media; import io.minio.BucketExistsArgs; import io.minio.MakeBucketArgs; import io.minio.MinioClient; import io.minio.UploadObjectArgs; import io.minio.errors.MinioException; import java.io.IOException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; /** * @description 测试MinIO * @version 1.0 */ public class MinioTest { static MinioClient minioClient = MinioClient.builder() .endpoint(\u0026#34;http://192.168.101.65:9000\u0026#34;) .credentials(\u0026#34;minioadmin\u0026#34;, \u0026#34;minioadmin\u0026#34;) .build(); //上传文件 @Test public void upload() { try { UploadObjectArgs testbucket = UploadObjectArgs.builder() .bucket(\u0026#34;testbucket\u0026#34;) // .object(\u0026#34;test001.mp4\u0026#34;) .object(\u0026#34;001/test001.mp4\u0026#34;)//添加子目录 .filename(\u0026#34;D:\\\\develop\\\\upload\\\\1mp4.temp\u0026#34;) .contentType(\u0026#34;video/mp4\u0026#34;)//默认根据扩展名确定文件内容类型，也可以指定 .build(); minioClient.uploadObject(testbucket); System.out.println(\u0026#34;上传成功\u0026#34;); } catch (Exception e) { e.printStackTrace(); System.out.println(\u0026#34;上传失败\u0026#34;); } } } 执行upload方法，分别测试向桶的根目录上传文件以及子目录上传文件。\n上传成功，通过web控制台查看文件，并预览文件。\n说明：\n设置contentType可以通过com.j256.simplemagic.ContentType枚举类查看常用的mimeType（媒体类型）\n通过扩展名得到mimeType，代码如下：\n1 2 3 4 5 6 7 //根据扩展名取出mimeType ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(\u0026#34;.mp4\u0026#34;); String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE;//通用mimeType，字节流 //通过扩展名来获得mimeType的类型 if(extensionMatch!=null){ mimeType = extensionMatch.getMimeType(); } 完善上边的代码，如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Test public void upload() { //根据扩展名取出mimeType ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(\u0026#34;.mp4\u0026#34;); String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE;//通用mimeType，字节流 //通过扩展名来获得mimeType的类型 if(extensionMatch!=null){ mimeType = extensionMatch.getMimeType(); } try { UploadObjectArgs testbucket = UploadObjectArgs.builder() .bucket(\u0026#34;testbucket\u0026#34;) // .object(\u0026#34;test001.mp4\u0026#34;) .object(\u0026#34;001/test001.mp4\u0026#34;)//添加子目录 .filename(\u0026#34;D:\\\\develop\\\\upload\\\\1mp4.temp\u0026#34;) .contentType(mimeType)//默认根据扩展名确定文件内容类型，也可以指定 .build(); minioClient.uploadObject(testbucket); System.out.println(\u0026#34;上传成功\u0026#34;); } catch (Exception e) { e.printStackTrace(); System.out.println(\u0026#34;上传失败\u0026#34;); } } 删除文件 下边测试删除文件 参考：https://docs.min.io/docs/java-client-api-reference#removeObject 1 2 3 4 5 6 7 8 9 10 11 @Test public void delete(){ try { minioClient.removeObject( RemoveObjectArgs.builder().bucket(\u0026#34;testbucket\u0026#34;).object(\u0026#34;001/test001.mp4\u0026#34;).build()); System.out.println(\u0026#34;删除成功\u0026#34;); } catch (Exception e) { e.printStackTrace(); System.out.println(\u0026#34;删除失败\u0026#34;); } } 查询文件 通过查询文件查看文件是否存在minio中。 参考：https://docs.min.io/docs/java-client-api-reference#getObject 1 2 3 4 5 6 7 8 9 10 11 12 13 //查询文件 @Test public void getFile() { GetObjectArgs getObjectArgs = GetObjectArgs.builder().bucket(\u0026#34;testbucket\u0026#34;).object(\u0026#34;test001.mp4\u0026#34;).build(); try( FilterInputStream inputStream = minioClient.getObject(getObjectArgs); FileOutputStream outputStream = new FileOutputStream(new File(\u0026#34;D:\\\\develop\\\\upload\\\\1_2.mp4\u0026#34;)); ) { IOUtils.copy(inputStream,outputStream); } catch (Exception e) { e.printStackTrace(); } } 校验文件的完整性，对文件计算出md5值，比较原始文件的md5和目标文件的md5，一致则说明完整 1 2 3 4 5 6 7 8 //校验文件的完整性对文件的内容进行md5 FileInputStream fileInputStream1 = new FileInputStream(new File(\u0026#34;D:\\\\develop\\\\upload\\\\1.mp4\u0026#34;)); String source_md5 = DigestUtils.md5Hex(fileInputStream1); FileInputStream fileInputStream = new FileInputStream(new File(\u0026#34;D:\\\\develop\\\\upload\\\\1a.mp4\u0026#34;)); String local_md5 = DigestUtils.md5Hex(fileInputStream); if(source_md5.equals(local_md5)){ System.out.println(\u0026#34;下载成功\u0026#34;); } 上传图片 需求分析 业务流程 课程图片是宣传课程非常重要的信息，在新增课程界面上传课程图片，也可以修改课程图片。\n上传课程图片总体上包括两部分：\n上传课程图片前端请求媒资管理服务将文件上传至分布式文件系统，并且在媒资管理数据库保存文件信息。 上传图片成功保存图片地址到课程基本信息表中。 详细流程如下：\n前端进入上传图片界面 上传图片，请求媒资管理服务。 媒资管理服务将图片文件存储在MinIO。 媒资管理记录文件信息到数据库。 前端请求内容管理服务保存课程信息，在内容管理数据库保存图片地址。 数据模型 涉及到的数据表有：课程信息表中的图片字段、媒资数据库的文件表，下边主要看媒资数据库的文件表： 准备环境 在nacos配置中minio的相关信息，进入media-service-dev.yaml: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.101.65:3306/xcplus_media?serverTimezone=UTC\u0026amp;userUnicode=true\u0026amp;useSSL=false\u0026amp; username: root password: mysql cloud: config: override-none: true minio: endpoint: http://192.168.101.65:9000 accessKey: minioadmin secretKey: minioadmin bucket: files: mediafiles videofiles: video 在media-service工程编写minio的配置类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.xuecheng.media.config; import io.minio.MinioClient; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @description minio配置 * @version 1.0 */ @Configuration public class MinioConfig { @Value(\u0026#34;${minio.endpoint}\u0026#34;) private String endpoint; @Value(\u0026#34;${minio.accessKey}\u0026#34;) private String accessKey; @Value(\u0026#34;${minio.secretKey}\u0026#34;) private String secretKey; @Bean public MinioClient minioClient() { MinioClient minioClient = MinioClient.builder() .endpoint(endpoint) .credentials(accessKey, secretKey) .build(); return minioClient; } } [!CAUTION]\n注意：若要使用**@ConfigurationPropertites**，要再类中添加Getter和Setter方法，该注解就是通过这两个方法进行配置的注入的，并且由于该类不在启动类的包下，故要在启动类上加上**@EnableConfigurationProperties(MinioConfig.class)**注解\n接口定义 根据需求分析，下边进行接口定义，此接口定义为一个通用的上传文件接口，可以上传图片或其它文件。\n首先分析接口：\n请求地址：/media/upload/coursefile\n请求内容：Content-Type: multipart/form-data;form-data; name=\u0026ldquo;filedata\u0026rdquo;; filename=\u0026ldquo;具体的文件名称\u0026rdquo;\n响应参数：文件信息，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \u0026#34;id\u0026#34;: \u0026#34;a16da7a132559daf9e1193166b3e7f52\u0026#34;, \u0026#34;companyId\u0026#34;: 1232141425, \u0026#34;companyName\u0026#34;: null, \u0026#34;filename\u0026#34;: \u0026#34;1.jpg\u0026#34;, \u0026#34;fileType\u0026#34;: \u0026#34;001001\u0026#34;, \u0026#34;tags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;bucket\u0026#34;: \u0026#34;/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg\u0026#34;, \u0026#34;fileId\u0026#34;: \u0026#34;a16da7a132559daf9e1193166b3e7f52\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;/testbucket/2022/09/12/a16da7a132559daf9e1193166b3e7f52.jpg\u0026#34;, \u0026#34;timelength\u0026#34;: null, \u0026#34;username\u0026#34;: null, \u0026#34;createDate\u0026#34;: \u0026#34;2022-09-12T21:57:18\u0026#34;, \u0026#34;changeDate\u0026#34;: null, \u0026#34;status\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;remark\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;auditStatus\u0026#34;: null, \u0026#34;auditMind\u0026#34;: null, \u0026#34;fileSize\u0026#34;: 248329 } 定义上传响应模型类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package com.xuecheng.media.model.dto; import com.xuecheng.media.model.po.MediaFiles; import lombok.Data; import lombok.ToString; /** * @description 上传普通文件成功响应结果 * @version 1.0 */ //以后可能需要再这里面添加参数，故先定义出来 @Data public class UploadFileResultDto extends MediaFiles { } 定义接口如下： 1 2 3 4 5 6 @ApiOperation(\u0026#34;上传文件\u0026#34;) @RequestMapping(value = \u0026#34;/upload/coursefile\u0026#34;, consumes = MediaType.MULTIPART_FORM_DATA_VALUE) public UploadFileResultDto upload(@RequestPart(\u0026#34;filedata\u0026#34;) MultipartFile upload) throws IOException { return null; } 接口定义好后可以用httpclient工具测试一下\n使用httpclient测试\n1 2 3 4 5 6 7 8 9 10 11 12 ### 上传文件 POST {{media_host}}/media/upload/coursefile Content-Type: multipart/form-data; boundary=WebAppBoundary --WebAppBoundary Content-Disposition: form-data; name=\u0026#34;filedata\u0026#34;; ### 这里用自己的文件名 filename=\u0026#34;1.jpg\u0026#34; Content-Type: application/octet-stream ### 这里用自己想要上传的文件的路径 \u0026lt; d:/develop/upload/1.jpg 接口开发 Dao开发 根据需求分析DAO层实现向media_files表插入一条记录，使用media_files表生成的mapper即可。、 Service开发 Service方法需要提供一个更加通用的保存文件的方法。\n定义请求参数类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 package com.xuecheng.media.model.dto; import com.xuecheng.media.model.po.MediaFiles; import lombok.Data; import lombok.ToString; /** * @description 上传普通文件请求参数 * @author Mr.M * @date 2022/9/12 18:49 * @version 1.0 */ @Data public class UploadFileParamsDto { /** * 文件名称 */ private String filename; /** * 文件类型（文档，音频，视频） */ private String fileType; /** * 文件大小 */ private Long fileSize; /** * 标签 */ private String tags; /** * 上传人 */ private String username; /** * 备注 */ private String remark; } 定义service接口： 1 2 3 4 5 6 7 8 /** * 上传文件 * @param companyId 机构id * @param uploadFileParamsDto 上传文件信息 * @param localFilePath 文件磁盘路径 * @return 文件信息 */ public UploadFileResultDto uploadFile(Long companyId, UploadFileParamsDto uploadFileParamsDto, String localFilePath); 实现方法如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 @Autowired MinioClient minioClient; @Autowired MediaFilesMapper mediaFilesMapper; //普通文件桶 @Value(\u0026#34;${minio.bucket.files}\u0026#34;) private String bucket_Files; //获取文件默认存储目录路径 年/月/日 private String getDefaultFolderPath() { SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;); String folder = sdf.format(new Date()).replace(\u0026#34;-\u0026#34;, \u0026#34;/\u0026#34;)+\u0026#34;/\u0026#34;; return folder; } //获取文件的md5 private String getFileMd5(File file) { try (FileInputStream fileInputStream = new FileInputStream(file)) { String fileMd5 = DigestUtils.md5Hex(fileInputStream); return fileMd5; } catch (Exception e) { e.printStackTrace(); return null; } } private String getMimeType(String extension){ if(extension==null) extension = \u0026#34;\u0026#34;; //根据扩展名取出mimeType ContentInfo extensionMatch = ContentInfoUtil.findExtensionMatch(extension); //通用mimeType，字节流 String mimeType = MediaType.APPLICATION_OCTET_STREAM_VALUE; if(extensionMatch!=null){ mimeType = extensionMatch.getMimeType(); } return mimeType; } /** * @description 将文件写入minIO * @param localFilePath 文件地址 * @param bucket 桶 * @param objectName 对象名称 * @return void */ public boolean addMediaFilesToMinIO(String localFilePath,String mimeType,String bucket, String objectName) { try { UploadObjectArgs testbucket = UploadObjectArgs.builder() .bucket(bucket) .object(objectName) .filename(localFilePath) .contentType(mimeType) .build(); minioClient.uploadObject(testbucket); log.debug(\u0026#34;上传文件到minio成功,bucket:{},objectName:{}\u0026#34;,bucket,objectName); System.out.println(\u0026#34;上传成功\u0026#34;); return true; } catch (Exception e) { e.printStackTrace(); log.error(\u0026#34;上传文件到minio出错,bucket:{},objectName:{},错误原因:{}\u0026#34;,bucket,objectName,e.getMessage(),e); XueChengPlusException.cast(\u0026#34;上传文件到文件系统失败\u0026#34;); } return false; } /** * @description 将文件信息添加到文件表 * @param companyId 机构id * @param fileMd5 文件md5值 * @param uploadFileParamsDto 上传文件的信息 * @param bucket 桶 * @param objectName 对象名称 * @return com.xuecheng.media.model.po.MediaFiles */ @Transactional public MediaFiles addMediaFilesToDb(Long companyId,String fileMd5,UploadFileParamsDto uploadFileParamsDto,String bucket,String objectName){ //从数据库查询文件 MediaFiles mediaFiles = mediaFilesMapper.selectById(fileMd5); if (mediaFiles == null) { mediaFiles = new MediaFiles(); //拷贝基本信息 BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles); mediaFiles.setId(fileMd5); mediaFiles.setFileId(fileMd5); mediaFiles.setCompanyId(companyId); mediaFiles.setUrl(\u0026#34;/\u0026#34; + bucket + \u0026#34;/\u0026#34; + objectName); mediaFiles.setBucket(bucket); mediaFiles.setFilePath(objectName); mediaFiles.setCreateDate(LocalDateTime.now()); mediaFiles.setAuditStatus(\u0026#34;002003\u0026#34;); mediaFiles.setStatus(\u0026#34;1\u0026#34;); //保存文件信息到文件表 int insert = mediaFilesMapper.insert(mediaFiles); if (insert \u0026lt; 0) { log.error(\u0026#34;保存文件信息到数据库失败,{}\u0026#34;,mediaFiles.toString()); XueChengPlusException.cast(\u0026#34;保存文件信息失败\u0026#34;); } log.debug(\u0026#34;保存文件信息到数据库成功,{}\u0026#34;,mediaFiles.toString()); } return mediaFiles; } @Transactional @Override public UploadFileResultDto uploadFile(Long companyId, UploadFileParamsDto uploadFileParamsDto, String localFilePath) { File file = new File(localFilePath); if (!file.exists()) { XueChengPlusException.cast(\u0026#34;文件不存在\u0026#34;); } //文件名称 String filename = uploadFileParamsDto.getFilename(); //文件扩展名 String extension = filename.substring(filename.lastIndexOf(\u0026#34;.\u0026#34;)); //文件mimeType String mimeType = getMimeType(extension); //文件的md5值 String fileMd5 = getFileMd5(file); //文件的默认目录 String defaultFolderPath = getDefaultFolderPath(); //存储到minio中的对象名(带目录) String objectName = defaultFolderPath + fileMd5 + exension; //将文件上传到minio boolean b = addMediaFilesToMinIO(localFilePath, mimeType, bucket_files, objectName); //文件大小 uploadFileParamsDto.setFileSize(file.length()); //将文件信息存储到数据库 MediaFiles mediaFiles = addMediaFilesToDb(companyId, fileMd5, uploadFileParamsDto, bucket_files, objectName); //准备返回数据 UploadFileResultDto uploadFileResultDto = new UploadFileResultDto(); BeanUtils.copyProperties(mediaFiles, uploadFileResultDto); return uploadFileResultDto; } 完善接口层 完善接口层代码 ： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 上传文件 * @param filedata * @return */ @ApiOperation(\u0026#34;上传文件\u0026#34;) @PostMapping(value = \u0026#34;/upload/coursefile\u0026#34;,consumes = MediaType.MULTIPART_FORM_DATA_VALUE) public UploadFileResultDto upload(@RequestPart(\u0026#34;filedata\u0026#34;)MultipartFile filedata) throws IOException { //1.设置文件信息 UploadFileParamsDto uploadFileParamsDto = new UploadFileParamsDto(); //1.1文件大小 uploadFileParamsDto.setFileSize(filedata.getSize()); //1.2文件名称 uploadFileParamsDto.setFilename(filedata.getOriginalFilename()); //1.3文件类型 uploadFileParamsDto.setFileType(\u0026#34;001002\u0026#34;); //2.创建临时文件，将文件临时存储到本地 File tempFile = File.createTempFile(\u0026#34;minio\u0026#34;, \u0026#34;temp\u0026#34;); filedata.transferTo(tempFile); //3.临时存储在本地的该文件路径 String localFilePath = tempFile.getAbsolutePath(); //4.TODO 获取companyId Long companyId = 1232141425L; //5.调用service上传文件 return mediaFileService.uploadFile(companyId,uploadFileParamsDto,localFilePath); } 接口测试 首先使用httpclient测试 1 2 3 4 5 6 7 8 9 ### 上传文件 POST {{media_host}}/media/upload/coursefile Content-Type: multipart/form-data; boundary=WebAppBoundary --WebAppBoundary Content-Disposition: form-data; name=\u0026#34;filedata\u0026#34;; filename=\u0026#34;1.jpg\u0026#34; Content-Type: application/octet-stream \u0026lt; d:/develop/upload/1.jpg 再进行前后端联调测试 在新增课程、编辑课程界面上传图，保存课程信息后再次进入编辑课程界面，查看是否可以正常保存课程图片信息。 上图图片完成后，进入媒资管理，查看文件列表中是否有刚刚上传的图片信息。 Service事务优化 上边的service方法优化后并测试通过，现在思考关于uploadFile方法的是否应该开启事务。 目前是在uploadFile方法上添加@Transactional，当调用uploadFile方法前会开启数据库事务，如果上传文件过程时间较长那么数据库的事务持续时间就会变长，这样数据库链接释放就慢，最终导致数据库链接不够用。 我们只将addMediaFilesToDb方法添加事务控制即可,uploadFile方法上的@Transactional注解去掉。 优化后如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Transactional public MediaFiles addMediaFilesToDb(Long companyId,String fileMd5,UploadFileParamsDto uploadFileParamsDto,String bucket,String objectName){ //从数据库查询文件 MediaFiles mediaFiles = mediaFilesMapper.selectById(fileMd5); if (mediaFiles == null) { mediaFiles = new MediaFiles(); //拷贝基本信息 BeanUtils.copyProperties(uploadFileParamsDto, mediaFiles); mediaFiles.setId(fileMd5); mediaFiles.setFileId(fileMd5); mediaFiles.setCompanyId(companyId); mediaFiles.setUrl(\u0026#34;/\u0026#34; + bucket + \u0026#34;/\u0026#34; + objectName); mediaFiles.setBucket(bucket); mediaFiles.setFilePath(objectName); mediaFiles.setCreateDate(LocalDateTime.now()); mediaFiles.setAuditStatus(\u0026#34;002003\u0026#34;); mediaFiles.setStatus(\u0026#34;1\u0026#34;); //保存文件信息到文件表 int insert = mediaFilesMapper.insert(mediaFiles); if (insert \u0026lt; 0) { log.error(\u0026#34;保存文件信息到数据库失败,{}\u0026#34;,mediaFiles.toString()); XueChengPlusException.cast(\u0026#34;保存文件信息失败\u0026#34;); } log.debug(\u0026#34;保存文件信息到数据库成功,{}\u0026#34;,mediaFiles.toString()); } return mediaFiles; } 我们人为在int insert = mediaFilesMapper.insert(mediaFiles);下边添加一个异常代码int a=1/0;\n测试是否事务控制。很遗憾，事务控制失败。\n方法上已经添加了@Transactional注解为什么该方法不能被事务控制呢？\n如果是在uploadFile方法上添加@Transactional注解就可以控制事务，去掉则不行。\n现在的问题其实是一个非事务方法调同类一个事务方法，事务无法控制，这是为什么？\n下边分析原因：\n如果在uploadFile方法上添加@Transactional注解，代理对象执行此方法前会开启事务，如下图： 如果在uploadFile方法上没有@Transactional注解，代理对象执行此方法前不进行事务控制，如下图： 所以判断该方法是否可以事务控制必须保证\n是通过代理对象调用此方法， 且此方法上添加了@Transactional注解。 现在在addMediaFilesToDb方法上添加@Transactional注解，也不会进行事务控制是因为并不是通过代理对象执行的addMediaFilesToDb方法。\n为了判断在uploadFile方法中去调用addMediaFilesToDb方法是否是通过代理对象去调用，我们可以打断点跟踪。\n我们发现在uploadFile方法中去调用addMediaFilesToDb方法不是通过代理对象去调用。\n如何解决呢？通过代理对象去调用addMediaFilesToDb方法即可解决。\n在MediaFileService的实现类中注入MediaFileService的代理对象，如下：\n1 2 @Autowired MediaFileService currentProxy; 将addMediaFilesToDb方法提成接口。\n1 2 3 4 5 6 7 8 9 10 11 /** * @description 将文件信息添加到文件表 * @param companyId 机构id * @param fileMd5 文件md5值 * @param uploadFileParamsDto 上传文件的信息 * @param bucket 桶 * @param objectName 对象名称 * @return com.xuecheng.media.model.po.MediaFiles */ public MediaFiles addMediaFilesToDb(Long companyId,String fileMd5,UploadFileParamsDto uploadFileParamsDto,String bucket,String objectName); 通过代理对象调用addMediaFilesToDb： 1 2 3 4 ..... //写入文件表 MediaFiles mediaFiles = currentProxy.addMediaFilesToDb(companyId, fileMd5, uploadFileParamsDto, bucket_files, objectName); .... 再次测试事务是否可以正常控制。 测试 ","date":"2024-10-06T00:00:00Z","image":"https://lazman-ll.github.io/p/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/zaixianjiaoyu_hu15330337887880486241.jpg","permalink":"https://lazman-ll.github.io/p/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/","title":"学成在线媒资管理模块"},{"content":"本模块主要是对学成在线项目的课程信息做管理，包括了课程的查询，增加等内容\n模块的需求分析 什么是需求分析 百度百科对需求分析的定义如下： 需求分析也称为软件需求分析、系统需求分析或需求分析工程等，是开发人员经过深入细致的调研和分析，准确理解用户和项目的功能、性能、可靠性等具体要求，将用户非形式的需求表述转化为完整的需求定义，从而确定系统必须做什么的过程。\n简单理解就是要搞清楚问题域，问题域就是用户的需求，软件要为用户解决什么问题，实现哪些功能，满足什么样的性能要求。\n如何作需求分析\n首先确认用户需求\n用户需求即用户的原始需求。通过用户访谈、问卷调查、开会讨论、查阅资料等调研手段梳理用户的原始需求。\n产品人员根据用户需求会绘制界面原型，通过界面原型再和用户确认需求。\n确认关键问题\n用户的原始需求可能 是含糊不清的，需求分析要从繁杂的问题中梳理出关键问题。比如：教学机构的老师想要将课程发布到网上，这是原始需求，根据这个用户需求我们需要进行扩展分析，扩展出几下几点：\n课程发布需要发布哪些信息 如果发布了不良信息怎么办？ 课程发布后用户怎么查看课程？ 例如：课程发布需要课程名称、课程介绍、课程价格、课程图片、师资等信息。继续延申分析：这么多课程信息进行归类，方便用户编辑，分为课程基本信息、课程营销信息、课程师资等信息。\n按照这样的思路对用户需求逐项分析，梳理出若干问题，再从中找到关键问题。比如：上边对课程信息分类后，哪些是关键信息，课程名称、课程图片、课程介绍等基本信息为关键信息，所以发布课程的第一步要编写课程基本信息。\n找到了关键问题，下一步就可以进行数据建模，创建课程基本信息表，并设计其中的字段。\n梳理业务流程\n业务流程是由一个或多个用户参与完成为了完成一个目标所进行的一系列的业务操作，不论是整个系统还是一个模块通常首先分析核心的业务流程，比如：内容管理模块的核心业务流程是课程发布，本项目的核心业务流程是学生选课学习流程。 数据建模\n数据建模要根据分析的关键问题将其相关的信息全部建模。比如：根据发布课程的用户需求，可创建课程基本信息表、课程营销信息表、课程师资表、课程发布记录表、课程审核记录表等。 编写需求规格说明书\n需求分析阶段的成果物是需求分析规格说明书，针对每一个问题编写需求用例，需求用例包括：功能名称、功能描述、参与者、基本事件流程、可选事件流、数据描述、前置条件、后置条件等内容。\n这里以添加课程的需求为例：\n项目 添加课程 功能名称 添加课程 功能描述 添加课程基本信息 参与者 教学机构管理员 前置条件 教学机构管理只允许向自己机构添加课程 拥有添加课程的权限 基本事件流程 1、登录教学机构平台 2、进入课程列表页面 3、点击添加课程按钮进入添加课程界面 4、填写课程基本信息 5、点击提交。 可选事件流程 成功：提示添加成功，跳转到课程营销信息添加界面 失败：提示具体的失败信息，用户根据失败信息进行修改。 数据描述 课程基本信息：课程id、课程名称、课程介绍、课程大分类、课程小分类、课程等级、课程图片、所属机构、课程创建时间、课程修改时间、课程状态 后置条件 向课程基本信息插入一条记录 补充说明 模块介绍 内容管理这个词存在于很多软件系统，什么是内容管理 ？\n百度百科解释如下：\n内容管理系统（content management system，CMS），是一种位于WEB前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）之间的软件系统。内容的创作人员、编辑人员、发布人员使用内容管理系统来提交、修改、审批、发布内容。这里指的“内容”可能包括文件、表格、图片、数据库中的数据甚至视频等一切你想要发布到Internet、Intranet以及Extranet网站的信息。\n本项目作为一个大型的在线教育平台，其内容管理模块主要对课程及相关内容进行管理，包括：课程的基本信息、课程图片、课程师资信息、课程的授课计划、课程视频、课程文档等内容的管理。\n业务流程 内容管理的业务由教学机构人员和平台的运营人员共同完成。\n教学机构人员的业务流程如下：\n登录教学机构。 维护课程信息，添加一门课程需要编辑课程的基本信息、上传课程图片、课程营销信息、课程计划、上传课程视频、课程师资信息等内容。 课程信息编辑完成，通过课程预览确认无误后提交课程审核。 待运营人员对课程审核通过后方可进行课程发布。 运营人员的业务流程如下：\n查询待审核的课程信息。 审核课程信息。 提交审核结果。 下图是课程编辑与发布的整体流程\n界面原型 产品工程师根据用户需求制作产品界面原型，开发工程师除了根据用户需求进行需求分析以外，还会根据界面原型上的元素信息进行需求分析。 数据模型 数据模型就是对应的数据表的设计，内容管理模块涉及9张基础表，如下所示：\n创建模块工程 模块工程结构 在第一章节创建了项目的父工程以及项目基础工程，如下图：\n下面就要创建内容管理模块的工程结构。本项目是一个前后端分离项目，前端与后端开发人员之间主要依据接口进行开发。下图是前后端交互的流程图：\n前端请求后端服务提供的接口。（通常为http协议 ） 后端服务的控制层Controller接收前端的请求。 Contorller层调用Service层进行业务处理。 Service层调用Dao持久层对数据持久化。 整个流程分为前端、接口层和业务层三部分。故模块工程的结构如下所示：\nxuecheng-plus-content-api：接口工程，为前端提供接口。 xuecheng-plus-content-service: 业务工程，为接口工程提供业务支撑。 xuecheng-plus-content-model: 数据模型工程，存储数据模型类、数据传输类型等。 将项目父工程及项目基础工程与之结合可得下图：\nxuecheng-plus-content：内容管理模块工程，负责聚合xuecheng-plus-content-api、xuecheng-plus-content-service、xuecheng-plus-content-model。 聚合项目又称为多模块项目，这种结构的目的是为了统一构建项目，也就是说我对根项目的任何mvn 命令操作，都会相应的执行到每一个被聚合的module项目中。\n聚合项目，根模块的打包方式必须为pom。 通过 \u0026lt;module\u0026gt; 标签指定被聚合的模块。 被聚合的模块根本无法感知到根模块的存在。 父子模块这种项目结构，本质上就是继承关系。聚合模块结构没有上下级区分，但这里的父子模块就要区分上下级了（这里的上下级不是指文件目录的上下级），子模块会继承父模块的相关依赖配置。\n父模块的打包方式必须为pom。\n子模块需要通过 \u0026lt;parent\u0026gt; 标签指定父模块的坐标。然后自由选择需要的依赖，如果此依赖在父模块已指定版本，则子模块不需要再管理版本。\n父模块的groupId和version会传递到子模块，父子模块作为一个整体，子模块不需要再声明，仅需要指定自己独有的artifactId即可，当然如果你依赖的父模块和你的项目不是同一个groupId时，你也可以指定子模块的groupId和version；\n父模块的依赖配置会传递到子模块，子模块不需要再单独引入依赖；\n父模块可以通过\u0026lt;dependencyManagement\u0026gt;管理依赖的版本，子模块可以自由灵活的选择需要的依赖，不需要再关心版本的问题。\n父子模块正好相反，父模块根本无法感知到哪个子模块把它当作爸爸。\n最佳实战\n在我们实际开发中，一般都是将聚合和父子这两种关系混合使用 不论父子模块还是聚合模块，根模块的打包方式都必须是pom，下面的模块可以是jar或者war这两种打包方式。 聚合模块这种项目结构，仅仅是为了方便统一管理操作所有的模块。根模块和它内部\u0026lt;module\u0026gt; 标签内的模块是一个整体，项目目录层级上可以不要求一定上下级，但必须保持一定的层级联系。你不能用自己创建的项目去管理操作spring的项目。 父子模块这种项目结构，仅仅是为了方便子模块对依赖的管理，子模块通过\u0026lt;parent\u0026gt; 标签，引入父模块的配置去约束子模块的依赖版本。也可以抽出共同的依赖给到父模块，子模块去继承它，减少每个子模块冗余的配置。项目层级没有要求，你可以引入任意的依赖当作父模块，比如spring-boot-starter。 创建模块工程 首先在项目根目录创建内容管理模块的父工程xuecheng-plus-content\n创建完成，只保留pom.xml文件，删除多余的文件。内容管理父工程的主要职责是聚合内容管理接口和内容管理接口实现两个工程，它的父工程是xuecheng-plus-parent。pom.xml如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 父工程为项目父工程xuecheng-plus-parent --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-parent\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../xuecheng-plus-parent\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content\u0026lt;/artifactId\u0026gt; \u0026lt;name\u0026gt;xuecheng-plus-content\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;xuecheng-plus-content\u0026lt;/description\u0026gt; \u0026lt;!-- 其本身既是内容管理其他模块的父工程也是模块聚合的跟工程 --\u0026gt; \u0026lt;!-- 所以打包方式必须为pom --\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;!-- 聚合的模块 --\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;xuecheng-plus-content-api\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;xuecheng-plus-content-model\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;xuecheng-plus-content-service\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;/project\u0026gt; 由于xuecheng-plus-content-api、xuecheng-plus-content-service及xuecheng-plus-content-model三个工程还没有创建所以modules报错。\n在xuecheng-plus-content下创建xuecheng-plus-content-model数据模型工程。\n创建完成，只保留包和pom.xml文件 ，删除多余的文件。修改pom.xml文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content-model\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 基本所有工程都会依赖于基础工程 --\u0026gt; \u0026lt;!-- 引入基础工程依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-base\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 在xuecheng-plus-content下创建xuecheng-plus-content-service接口实现工程。\n创建完成，只保留包(即src包)和pom.xml文件 ，删除多余的文件，pom.xml如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content-service\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content-model\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 在xuecheng-plus-content下创建xuecheng-plus-content-api接口工程。\n创建完成，只保留包(即src包)和pom.xml文件 ，删除多余的文件，pom.xml如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content-api\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 引入service包会传递依赖项目基础工程 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content-service\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; xuecheng-plus-content-api接口工程的父工程是xuecheng-plus-content，它依赖了xuecheng-plus-base基础工程。\n到此内容管理模块的四个工程创建完毕，工程结构图如下：\n课程查询 需求分析 业务流程 教学机构人员点击课程管理首先进入课程查询界面 在课程进行列表查询页面输入查询条件查询课程信息 当不输入查询条件时输入全部课程信息。 输入查询条件查询符合条件的课程信息。 约束：本教学机构查询本机构的课程信息。 数据模型 课程查询功能涉及的数据表：课程基本信息表\n下边从查询条件、查询列表两个方面分析数据模型\n查询条件：\n包括：课程名称、课程审核状态、课程发布状态\n课程名称：可以模糊搜索\n课程审核状态：未提交、已提交、审核通过、审核未通过\n课程发布状态：未发布、已发布、已下线\n因为是分页查询所以查询条件中还要包括当前页码、每页显示记录数。\n查询结果：\n查询结果中包括：课程id、课程名称、任务数、创建时间、是否付费、审核状态、类型，操作 任务数：该课程所包含的课程计划数，即课程章节数。 是否付费：课程包括免费、收费两种。 类型：录播、直播。 因为是分页查询所以查询结果中还要包括总记录数、当前页、每页显示记录数。 创建数据库表及PO类型 创建数据库表 黑马所给的虚拟机中已经将数据库表全都建好，无需我们自己建表 若是想要自己建表，可以直接执行其给的sql语句文件。 生成PO类 PO即持久对象(Persistent Object)，它们是由一组属性和属性的get和set方法组成，PO对应于数据库的表。\n在开发持久层代码时需要根据数据表编写PO类，在实际开发中通常使用代码生成器（工具）生成PO类的代码。由于在需求分析阶段对数据模型进行分析，PO类对应于数据模型，所以在需求分析阶段即可使用工具生成PO类，为下面的接口定义准备好模型类。\n在企业开发中通常使用代码生成工具去自动生成这些文件，本项目使用mybatis-plus的generator工程生成PO类、Mapper接口、Mapper的xml文件，地址在：generator工程所在地址\n本项目可直接使用黑马提供的xuecheng-plus-generator工程，将其解压后，直接复制到项目的根目录下，并在idea中打开xuecheng-plus-generator工程的pom.xml，右键 点击“Add as Maven Project” 自动识别maven工程，即可。\n本次生成内容管理模块的PO类、Mapper接口和Mapper的xml文件 ，找到ContentCodeGenerator类，如下图：\n修改ContentCodeGenerator类中的信息，包括：数据库地址、数据库账号、数据库密码、生成的表、生成路径，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //数据库账号 private static final String DATA_SOURCE_USER_NAME = \u0026#34;root\u0026#34;; //数据库密码 private static final String DATA_SOURCE_PASSWORD = \u0026#34;mysql\u0026#34;; //生成的表 private static final String[] TABLE_NAMES = new String[]{ \u0026#34;course_base\u0026#34;, \u0026#34;course_market\u0026#34;, \u0026#34;course_teacher\u0026#34;, \u0026#34;course_category\u0026#34;, \u0026#34;teachplan\u0026#34;, \u0026#34;teachplan_media\u0026#34;, \u0026#34;course_publish\u0026#34;, \u0026#34;course_publish_pre\u0026#34; }; // TODO 默认生成entity，需要生成DTO修改此变量 // 一般情况下要先生成 DTO类 然后修改此参数再生成 PO 类。 private static final Boolean IS_DTO = false; public static void main(String[] args) { .... //生成路径 gc.setOutputDir(System.getProperty(\u0026#34;user.dir\u0026#34;) + \u0026#34;/xuecheng-plus-generator/src/main/java\u0026#34;); .... // 数据库配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setDbType(DbType.MYSQL); dsc.setUrl(\u0026#34;jdbc:mysql://192.168.101.65:3306/xcplus_\u0026#34; + SERVICE_NAME+\u0026#34;166\u0026#34; + \u0026#34;?serverTimezone=UTC\u0026amp;useUnicode=true\u0026amp;useSSL=false\u0026amp;characterEncoding=utf8\u0026#34;); ... 修改完成，执行该类的main方法，自动生成content包，如下：\n在该包下自动生成了内容管理模块的controller、mapper、po及service相关代码，这里我们只需要po类。将po类拷贝到model工程中的po包下。\n打开一个PO类发现编译报错，这是缺少依赖包导致，本项目使用的持久层框架是MyBatisPlus，在生成的po类中加了一些MyBatisPlus框架的注解，这里需要添加MyBatisPlus框架的依赖，消除错误。下边在model工程添加依赖\n1 2 3 4 5 6 \u0026lt;!--存在mybatisplus注解添加相关注解保证不报错--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-annotation\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus-boot-starter.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 设计接口 接口设计分析 设计一个接口需要包括以下几个方面：\n协议\n通常协议采用HTTP，查询类接口通常为get或post，查询条件较少的使用get，较多的使用post。本接口使用 http post。\n还要确定content-type，参数以什么数据格式提交，结果以什么数据格式响应。一般情况没有特殊情况结果以json 格式响应。\n分析请求参数\n根据前边对数据模型的分析，请求参数为：课程名称、课程审核状态、当前页码、每页显示记录数。根据分析的请求参数定义模型类。 分析响应结果\n根据前边对数据模型的分析，响应结果为数据列表加一些分页信息（总记录数、当前页、每页显示记录数）。\n数据列表中数据的属性包括：课程id、课程名称、任务数、创建时间、审核状态、类型。\n[!CAUTION]\n注意：查询结果中的审核状态为数据字典中的代码字段，前端会根据审核状态代码找到对应的名称显示。根据分析的响应结果定义模型类。\n分析完成，使用SpringBoot注解开发一个Http接口。\n使用接口文档工具查看接口的内容。\n接口中调用Service方法完成业务处理。\n接口请求示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 POST /content/course/list?pageNo=2\u0026amp;pageSize=1 Content-Type: application/json ###请求参数 { \u0026#34;auditStatus\u0026#34;: \u0026#34;202002\u0026#34;, \u0026#34;courseName\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;publishStatus\u0026#34;:\u0026#34;\u0026#34; } ###成功响应结果 { \u0026#34;items\u0026#34;: [ { \u0026#34;id\u0026#34;: 26, \u0026#34;companyId\u0026#34;: 1232141425, \u0026#34;companyName\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;spring cloud实战\u0026#34;, \u0026#34;users\u0026#34;: \u0026#34;所有人\u0026#34;, \u0026#34;tags\u0026#34;: null, \u0026#34;mt\u0026#34;: \u0026#34;1-3\u0026#34;, \u0026#34;mtName\u0026#34;: null, \u0026#34;st\u0026#34;: \u0026#34;1-3-2\u0026#34;, \u0026#34;stName\u0026#34;: null, \u0026#34;grade\u0026#34;: \u0026#34;200003\u0026#34;, \u0026#34;teachmode\u0026#34;: \u0026#34;201001\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;本课程主要从四个章节进行讲解： 1.微服务架构入门 2.spring cloud 基础入门 3.实战Spring Boot 4.注册中心eureka。\u0026#34;, \u0026#34;pic\u0026#34;: \u0026#34;https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg\u0026#34;, \u0026#34;createDate\u0026#34;: \u0026#34;2019-09-04 09:56:19\u0026#34;, \u0026#34;changeDate\u0026#34;: \u0026#34;2021-12-26 22:10:38\u0026#34;, \u0026#34;createPeople\u0026#34;: null, \u0026#34;changePeople\u0026#34;: null, \u0026#34;auditStatus\u0026#34;: \u0026#34;202002\u0026#34;, \u0026#34;auditMind\u0026#34;: null, \u0026#34;auditNums\u0026#34;: 0, \u0026#34;auditDate\u0026#34;: null, \u0026#34;auditPeople\u0026#34;: null, \u0026#34;status\u0026#34;: 1, \u0026#34;coursePubId\u0026#34;: null, \u0026#34;coursePubDate\u0026#34;: null } ], \u0026#34;counts\u0026#34;: 23, \u0026#34;page\u0026#34;: 2, \u0026#34;pageSize\u0026#34;: 1 } 3.3.2 定义模型类 根据接口分析需要定义模型类接收请求的参数，并定义模型类用于响应结果。\n分页查询模型类\n由于分页查询这一类的接口在项目较多，这里针对分页查询的参数（当前页码、每页显示记录数）单独在xuecheng-plus-base基础工程中定义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.xuecheng.base.model; import lombok.Data; import lombok.ToString; import lombok.extern.java.Log; /** * @description 分页查询通用参数 * @author Mr.M * @date 2022/9/6 14:02 * @version 1.0 */ @Data @AllArgsConstructor @NoArgsConstructor public class PageParams { //当前页码 @ApiModelProperty(\u0026#34;当前页码\u0026#34;) private Long pageNo = 1L; //每页记录数默认值 @ApiModelProperty(\u0026#34;每页记录数\u0026#34;) private Long pageSize = 10L; } 由于上边类中用到了lombok注解所以在base工程添加依赖包如下：\n1 2 3 4 5 6 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 查询条件模型类\n除了分页查询参数，剩下的就是课程查询的特有参数，此时需要在内容管理的model工程中定义课程查询参数模型类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.xuecheng.content.model.dto; import io.swagger.annotations.ApiModelProperty; import lombok.Data; /** * @description 课程查询参数Dto */ @Data public class QueryCourseParamsDto { //审核状态 @ApiModelProperty(\u0026#34;审核状态\u0026#34;) private String auditStatus; //课程名称 @ApiModelProperty(\u0026#34;课程名称\u0026#34;) private String courseName; //发布状态 @ApiModelProperty(\u0026#34;发布状态\u0026#34;) private String publishStatus; } 响应模型类\n根据接口分析，下边定义响应结果模型类。针对分页查询结果经过分析也存在固定的数据和格式，所以在base工程定义一个基础的模型类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.xuecheng.base.model; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; import java.util.List; /** * 分页查询结果模型类 */ @Data @NoArgsConstructor @AllArgsConstructor public class PageResult\u0026lt;T\u0026gt; implements Serializable { // 数据列表 private List\u0026lt;T\u0026gt; items; //总记录数 private long counts; //当前页码 private long page; //每页记录数 private long pageSize; } 此模型类中定义了List属性，此属性存放数据列表，且支持泛型，课程查询接口的返回类型可以是此模型类型。课程查询接口使用的泛型为相应的CourseBase，即生成的课程基本信息表的PO类。\n现在项目中有两类模型类：DTO数据传输对象、PO持久化对象，DTO用于接口层向业务层之间传输数据，PO用于业务层与持久层之间传输数据，有些项目还会设置VO对象，VO对象用在前端与接口层之间传输数据，如下图：\n当前端有多个平台且接口存在差异时就需要设置VO对象用于前端和接口层传输数据。比如：\n课程列表查询接口，根据需求用户在手机端也要查询课程信息，此时课程查询接口是否需要编写手机端和PC端两个接口呢？如果用户要求通过手机和PC的查询条件或查询结果不一样，此时就需要定义两个Controller课程查询接口，每个接口定义VO对象与前端传输数据。\n手机查询：根据课程状态查询，查询结果只有课程名称和课程状态。\nPC查询：可以根据课程名称、课程状态、课程审核状态等条件查询，查询结果也比手机查询结果内容多。\n此时，Service业务层尽量提供一个业务接口，即使两个前端接口需要的数据不一样，Service可以提供一个最全查询结果，由Controller进行数据整合。如下图：\n如果前端的接口没有多样性且比较固定，此时可以取消VO，只用DTO即可。如下图：\n定义接口 根据分析，此接口提供 HTTP post协议，查询条件以json格式提交，响应结果为json 格式。可使用SpringBoot注解在Controller类中实现。即为（@RequestBody和@ResponceBody）\n首先在api工程中添加依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content-service\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--cloud的基础环境包--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-context\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot 的 Spring Web MVC 集成 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 排除 Spring Boot 依赖的日志包冲突 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot 集成 log4j2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot 集成 swagger --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.spring4all\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;swagger-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 定义controller方法\n说明：pageParams分页参数通过url的key/value传入，queryCourseParams通过json数据传入，使用@RequestBody注解将json转成QueryCourseParamsDto对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.xuecheng.content.api; import com.xuecheng.base.model.PageParams; import com.xuecheng.base.model.PageResult; import com.xuecheng.content.model.dto.QueryCourseParamsDto; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; /** * @description 课程信息编辑接口 * @author Mr.M * @date 2022/9/6 11:29 * @version 1.0 */ @RestController public class CourseBaseInfoController { @PostMapping(\u0026#34;/course/list\u0026#34;) public PageResult\u0026lt;CourseBase\u0026gt; list(PageParams pageParams, @RequestBody QueryCourseParamsDto queryCourseParams){ return null; } } 定义启动类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.xuecheng; import com.spring4all.swagger.EnableSwagger2Doc; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.scheduling.annotation.EnableScheduling; @SpringBootApplication //该注解用于使swagger接口文档生效 @EnableSwagger2Doc public class ContentApplication { public static void main(String[] args) { SpringApplication.run(ContentApplication.class, args); } } 添加配置文件\n创建 log4j2-dev.xml、bootstrap.yml文件。\nbootstrap.yml内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 server: servlet: context-path: /content #配置url路径中localhost后的根路径 port: 63040 #微服务配置 spring: application: name: content-api #数据库配置 datasource: driver-class-name: com.mysql.cj.jdbc.Driver #这里要将数据库名，数据库用户及密码修改为自己的 url: jdbc:mysql://192.168.101.65:3306/xcplus_content?serverTimezone=UTC\u0026amp;userUnicode=true\u0026amp;useSSL=false\u0026amp; username: root password: mysql # 日志文件配置路径 logging: config: classpath:log4j2-dev.xml log4j2-dev.xml内容如下：\n这种内容可直接到网上粘贴复制，无需自己编写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Configuration monitorInterval=\u0026#34;180\u0026#34; packages=\u0026#34;\u0026#34;\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;property name=\u0026#34;logdir\u0026#34;\u0026gt;logs\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;PATTERN\u0026#34;\u0026gt;%date{YYYY-MM-dd HH:mm:ss,SSS} %level [%thread][%file:%line] - %msg%n%throwable\u0026lt;/property\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;Appenders\u0026gt; \u0026lt;Console name=\u0026#34;Console\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;${PATTERN}\u0026#34;/\u0026gt; \u0026lt;/Console\u0026gt; \u0026lt;RollingFile name=\u0026#34;ErrorAppender\u0026#34; fileName=\u0026#34;${logdir}/error.log\u0026#34; filePattern=\u0026#34;${logdir}/$${date:yyyy-MM-dd}/error.%d{yyyy-MM-dd-HH}.log\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;${PATTERN}\u0026#34;/\u0026gt; \u0026lt;ThresholdFilter level=\u0026#34;ERROR\u0026#34; onMatch=\u0026#34;ACCEPT\u0026#34; onMismatch=\u0026#34;DENY\u0026#34;/\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy interval=\u0026#34;1\u0026#34; modulate=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;RollingFile name=\u0026#34;DebugAppender\u0026#34; fileName=\u0026#34;${logdir}/info.log\u0026#34; filePattern=\u0026#34;${logdir}/$${date:yyyy-MM-dd}/info.%d{yyyy-MM-dd-HH}.log\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;${PATTERN}\u0026#34;/\u0026gt; \u0026lt;ThresholdFilter level=\u0026#34;DEBUG\u0026#34; onMatch=\u0026#34;ACCEPT\u0026#34; onMismatch=\u0026#34;DENY\u0026#34;/\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy interval=\u0026#34;1\u0026#34; modulate=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;!--异步appender--\u0026gt; \u0026lt;Async name=\u0026#34;AsyncAppender\u0026#34; includeLocation=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;ErrorAppender\u0026#34;/\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;DebugAppender\u0026#34;/\u0026gt; \u0026lt;/Async\u0026gt; \u0026lt;/Appenders\u0026gt; \u0026lt;Loggers\u0026gt; \u0026lt;!--过滤掉spring和mybatis的一些无用的debug信息 \u0026lt;logger name=\u0026#34;org.springframework\u0026#34; level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;org.mybatis\u0026#34; level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt;--\u0026gt; \u0026lt;logger name=\u0026#34;cn.itcast.wanxinp2p.consumer.mapper\u0026#34; level=\u0026#34;DEBUG\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;springfox\u0026#34; level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;org.apache.http\u0026#34; level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;com.netflix.discovery\u0026#34; level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;RocketmqCommon\u0026#34; level=\u0026#34;INFO\u0026#34; \u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;RocketmqRemoting\u0026#34; level=\u0026#34;INFO\u0026#34; \u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;RocketmqClient\u0026#34; level=\u0026#34;WARN\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;org.dromara.hmily\u0026#34; level=\u0026#34;WARN\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;org.dromara.hmily.lottery\u0026#34; level=\u0026#34;WARN\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;org.dromara.hmily.bonuspoint\u0026#34; level=\u0026#34;WARN\u0026#34;\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;!--OFF 0--\u0026gt; \u0026lt;!--FATAL 100--\u0026gt; \u0026lt;!--ERROR 200--\u0026gt; \u0026lt;!--WARN 300--\u0026gt; \u0026lt;!--INFO 400--\u0026gt; \u0026lt;!--DEBUG 500--\u0026gt; \u0026lt;!--TRACE 600--\u0026gt; \u0026lt;!--ALL Integer.MAX_VALUE--\u0026gt; \u0026lt;Root level=\u0026#34;DEBUG\u0026#34; includeLocation=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;AsyncAppender\u0026#34;/\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;Console\u0026#34;/\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;DebugAppender\u0026#34;/\u0026gt; \u0026lt;/Root\u0026gt; \u0026lt;/Loggers\u0026gt; \u0026lt;/Configuration\u0026gt; 这里使用bootstrap.yaml文件进行配置而不是application.yaml进行配置\n加载顺序： bootstrap.yaml 在 Spring Boot 启动过程中比 application.yaml 更早加载。Bootstrap 配置主要用于初始化一些基础配置，比如服务注册中心的地址、配置中心的地址等，这些是在应用开始起步前就需要的配置。 application.yaml 文件则在应用的上下文加载后进行加载，主要用于应用的具体配置。 微服务的特性： 在微服务架构中，服务之间通常会进行注册和发现，因此bootstrap.yaml 更适合放置与服务注册、配置中心等相关的配置。 使用 bootstrap.yaml 可以更清晰地将应用级配置和系统级配置分开，使得项目结构更加清晰和易于管理。 下边启动服务，测试接口是否可以正常请求\n访问swagger接口文档，查看接口接口信息\n通过swagger提供的方法进行接口的测试，点击下图中的Try it out即可\n接口测试过程中我们发现，LocalDateTime类型的数据转json后数据格式并不是我们要的年月日时分秒不是我们想要的，如下图：\n解决办法：在base工程com.xuecheng.base.config包下加配置LocalDateTimeConfig 类实现转json时字符串与LocalDateTime类型的转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer; import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer; import org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; /** * 日期在序列化时需要指定格式 */ @Configuration public class LocalDateTimeConfig { /* * 序列化内容 * LocalDateTime -\u0026gt; String * 服务端返回给客户端内容 * */ @Bean public LocalDateTimeSerializer localDateTimeSerializer() { return new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); } /* * 反序列化内容 * String -\u0026gt; LocalDateTime * 客户端传入服务端数据 * */ @Bean public LocalDateTimeDeserializer localDateTimeDeserializer() { return new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); } // 配置 @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { return builder -\u0026gt; { builder.serializerByType(LocalDateTime.class, localDateTimeSerializer()); builder.deserializerByType(LocalDateTime.class, localDateTimeDeserializer()); }; } } Swagger介绍 在前后端分离开发中通常由后端程序员设计接口，完成后需要编写接口文档，最后将文档交给前端工程师，前端工程师参考文档进行开发。可以通过一些工具快速生成接口文档 ，本项目通过Swagger生成接口在线文档 。\n什么是Swagger？\nOpenAPI规范（OpenAPI Specification 简称OAS）是Linux基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程，并且已经发布并开源在github上。swagger项目地址\nSwagger是全球最大的OpenAPI规范（OAS）API开发工具框架，Swagger是一个在线接口文档的生成工具，前后端开发人员依据接口文档进行开发。swagger官网 Spring Boot 可以集成Swagger，Swaager根据Controller类中的注解生成接口文档 ，只要添加Swagger的依赖和配置信息即可使用它。SpringBoot集成Swagger步骤如下：\n在想要实现的模块(课程查询接口在API中，故此处为API工程)中添加swagger-spring-boot-starter依赖\n1 2 3 4 5 \u0026lt;!-- Spring Boot 集成 swagger --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.spring4all\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;swagger-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在 bootstrap.yml(application.yaml也可)中配置swagger的扫描包路径及其它信息，base-package为扫描的包路径，扫描Controller类。\n1 2 3 4 5 6 swagger: title: \u0026#34;学成在线内容管理系统\u0026#34; description: \u0026#34;内容系统管理系统对课程相关信息进行管理\u0026#34; base-package: com.xuecheng.content enabled: true version: 1.0.0 在启动类中添加@EnableSwagger2Doc注解，启动服务即可访问。\n接口文档中会有关于接口参数的说明，在模型类上也可以添加注解对模型类中的属性进行说明，方便对接口文档的阅读。比如：下边标红的属性名称，可以通过swaager注解标注一个中文名称，方便阅读接口文档。\n标注的方法非常简单：找到模型类，在属性上添加注解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class PageParams { ... @ApiModelProperty(\u0026#34;当前页码\u0026#34;) private Long pageNo = 1L; @ApiModelProperty(\u0026#34;每页记录数默认值\u0026#34;) private Long pageSize = 30L; ... public class QueryCourseParamsDto { //审核状态 @ApiModelProperty(\u0026#34;审核状态\u0026#34;) private String auditStatus; //课程名称 @ApiModelProperty(\u0026#34;课程名称\u0026#34;) private String courseName; } 重启服务，再次进入接口文档，如下图：\n在Java类中添加Swagger的注解即可生成Swagger接口，常用Swagger注解如下\n1 2 3 4 5 6 7 8 9 10 11 @Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiModelProperty：用对象接收参数时，描述对象的一个字段 @ApiResponse：HTTP响应其中1个描述 @ApiResponses：HTTP响应整体描述 @ApiIgnore：使用该注解忽略这个API @ApiError ：发生错误返回的信息 @ApiImplicitParam：一个请求参数 @ApiImplicitParams：多个请求参数 开发持久层 生成 mapper 本项目使用MyBatis-Plus开发持久层，需要创建PO类、Mapper接口、Mapper的xml文件，每个PO类对应数据库的每张表，每张表需要创建一个Mapper接口和Mapper的xml映射文件 。 下边将使用generator工程生成的mapper接口和mapper映射文件拷贝到service工程下的com/xuecheng/content/mapper的包下。 测试mapper 下边对mapper进行单元测试，测试course_base表的查询接口。\n首先在service工程的pom.xml中添加依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-content-model\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySQL 驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis plus的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-context\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot 集成 Junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 排除 Spring Boot 依赖的日志包冲突 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring Boot 集成 log4j2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 配置扫描mapper及分页插件，在com.xuecheng.content.config包下编写以下配置类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.xuecheng.content.config; import com.baomidou.mybatisplus.annotation.DbType; import com.baomidou.mybatisplus.autoconfigure.ConfigurationCustomizer; import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor; import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor; import org.mybatis.spring.annotation.MapperScan; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * \u0026lt;P\u0026gt; * Mybatis-Plus 配置 * \u0026lt;/p\u0026gt; */ @Configuration //若在每个mapper类上都加了@Mapper注解，就无需该扫描注解 @MapperScan(\u0026#34;com.xuecheng.content.mapper\u0026#34;) public class MybatisPlusConfig { /** * 定义分页拦截器 */ @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 分页插件的原理：\n首先分页参数放到ThreadLocal中，拦截执行的sql，根据数据库类型添加对应的分页语句重写sql，例如：(select * from table where a) 转换为 (select count(*) from table where a)和(select * from table where a limit ,)计算出了total总条数、pageNum当前第几页、pageSize每页大小和当前页的数据，是否为首页，是否为尾页，总页数等。\n单元测试所需要的配置文件\n由于service包是一个工具包，没有启动类，故我们在进行单元测试的时候需要自行在测试包下添加相应的配置文件和启动类\n在test/resources下创建 log4j2-dev.xml、bootstrap.yml，直接复制api工程下的即可。\n编写启动类：单元测试工作在test目录，在test下添加启动类，直接复制api工程下的启动类即可。\n编写测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package com.xuecheng.content; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.xuecheng.base.model.PageParams; import com.xuecheng.base.model.PageResult; import com.xuecheng.content.mapper.CourseBaseMapper; import com.xuecheng.content.model.dto.QueryCourseParamsDto; import com.xuecheng.content.model.po.CourseBase; import org.apache.commons.lang.StringUtils; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.List; @SpringBootTest class CourseBaseMapperTests { @Autowired CourseBaseMapper courseBaseMapper; @Test void testCourseBaseMapper() { CourseBase courseBase = courseBaseMapper.selectById(74L); Assertions.assertNotNull(courseBase); //测试查询接口 LambdaQueryWrapper\u0026lt;CourseBase\u0026gt; queryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;(); //查询条件 QueryCourseParamsDto queryCourseParamsDto = new QueryCourseParamsDto(); queryCourseParamsDto.setCourseName(\u0026#34;java\u0026#34;); queryCourseParamsDto.setAuditStatus(\u0026#34;202004\u0026#34;); queryCourseParamsDto.setPublishStatus(\u0026#34;203001\u0026#34;); //拼接查询条件 //根据课程名称模糊查询 name like \u0026#39;%名称%\u0026#39; queryWrapper.like(StringUtils.isNotEmpty(queryCourseParamsDto.getCourseName()),CourseBase::getName,queryCourseParamsDto.getCourseName()); //根据课程审核状态 queryWrapper.eq(StringUtils.isNotEmpty(queryCourseParamsDto.getAuditStatus()),CourseBase::getAuditStatus,queryCourseParamsDto.getAuditStatus()); //分页参数 PageParams pageParams = new PageParams(); pageParams.setPageNo(1L);//页码 pageParams.setPageSize(3L);//每页记录数 Page\u0026lt;CourseBase\u0026gt; page = new Page\u0026lt;\u0026gt;(pageParams.getPageNo(), pageParams.getPageSize()); //分页查询E page 分页参数, @Param(\u0026#34;ew\u0026#34;) Wrapper\u0026lt;T\u0026gt; queryWrapper 查询条件 Page\u0026lt;CourseBase\u0026gt; pageResult = courseBaseMapper.selectPage(page, queryWrapper); //数据 List\u0026lt;CourseBase\u0026gt; items = pageResult.getRecords(); //总记录数 long total = pageResult.getTotal(); //准备返回数据 List\u0026lt;T\u0026gt; items, long counts, long page, long pageSize PageResult\u0026lt;CourseBase\u0026gt; courseBasePageResult = new PageResult\u0026lt;\u0026gt;(items, total, pageParams.getPageNo(), pageParams.getPageSize()); System.out.println(courseBasePageResult); } } 开发业务层 创建数据字典 课程基本信息查询的主要数据来源是课程基本信息表，这里有一个点需要注意，就是课程的审核状态、发布状态。\n审核状态在查询条件和查询结果中都存在，审核状态包括：未审核、审核通过、审核未通过三种，下边思考一个问题：一个课程的审核状态如果是“审核未通过”那么在课程基本信息表记录“审核未通过”三个字合适吗？\n如果将“审核未通过”五个字记录在课程基本信息表中，显示出来的审核状态就是“审核未通过”这五个字，看起来没有什么问题，如果有一天客户想要将审核未通过的记录在显示时改为“未通过”三个字，怎么办？\n这时你可以需要批量处理数据库中记录了，写一个 update 语句，审核状态等于“审核未通过”的全部更新 为“未通过”。看起来解决了问题，如果有一天客户又让改了呢？和审核状态同类的有好多这样的信息，比如：课程状态、课程类型、用户类型等等，这一类数据有一个共同点就是它有一些分类项，且这些分类项较为固定。针对这些数据，为了提高系统的可扩展性，专门定义数据字典表去维护。\n下边是课程审核状态的定义：每一项都由代码和名称组成。\n1 2 3 4 5 [ {\u0026#34;code\u0026#34;:\u0026#34;202001\u0026#34;,\u0026#34;desc\u0026#34;:\u0026#34;审核未通过\u0026#34;}, {\u0026#34;code\u0026#34;:\u0026#34;202002\u0026#34;,\u0026#34;desc\u0026#34;:\u0026#34;未审核\u0026#34;}, {\u0026#34;code\u0026#34;:\u0026#34;202003\u0026#34;,\u0026#34;desc\u0026#34;:\u0026#34;审核通过\u0026#34;} ] 如果该课程的审核状态为审核未通过，那么我们在课程基本信息表存储202001，也就是审核未通过对应的代码，这样查询出的数据在前端展示时根据代码取出它对应的内容显示给用户。如果用户要修改“审核未通过”的显示内容只需要在数据字典表修改，无需修改课程基本信息表。 数据字典表在系统管理数据库中存储，首先导入系统管理数据库，创建系统管理服务的数据库，导入黑马提供的xcplus_system.sql脚本，或者直接使用虚拟机中本就有的xcplus_system数据库。\n编写Service 接下来开发Service方法，首先创建Service接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.xuecheng.content.service; import com.xuecheng.base.model.PageParams; import com.xuecheng.base.model.PageResult; import com.xuecheng.content.model.dto.QueryCourseParamsDto; import com.xuecheng.content.model.po.CourseBase; /** * @description 课程基本信息管理业务接口 / public interface CourseBaseInfoService { /** * 课程信息分页查询 * @param pageParams 分页参数 * @param queryCourseParamsDto 查询条件 * @return 查询结果 */ public PageResult\u0026lt;CourseBase\u0026gt; queryCourseBasePages(PageParams pageParams, QueryCourseParamsDto queryCourseParamsDto); } 在创建接口的实现类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.xuecheng.content.service.impl; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.xuecheng.base.model.PageParams; import com.xuecheng.base.model.PageResult; import com.xuecheng.content.mapper.CourseBaseMapper; import com.xuecheng.content.model.dto.QueryCourseParamsDto; import com.xuecheng.content.model.po.CourseBase; import com.xuecheng.content.service.CourseBaseInfoService; import org.apache.commons.lang3.StringUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; /** * @description 课程信息管理业务接口实现类 * @author Mr.M * @date 2022/9/6 21:45 * @version 1.0 */ @Service public class CourseBaseInfoServiceImpl implements CourseBaseInfoService { @Autowired CourseBaseMapper courseBaseMapper; @Override public PageResult\u0026lt;CourseBase\u0026gt; queryCourseBasePages(PageParams pageParams, QueryCourseParamsDto queryCourseParamsDto) { //1.创建查询条件 LambdaQueryWrapper\u0026lt;CourseBase\u0026gt; queryWrapper=new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.like(StringUtils.isNotEmpty(queryCourseParamsDto.getCourseName()), CourseBase::getName,queryCourseParamsDto.getCourseName()) .eq(StringUtils.isNotEmpty(queryCourseParamsDto.getAuditStatus()), CourseBase::getAuditStatus,queryCourseParamsDto.getAuditStatus()) .eq(StringUtils.isNotEmpty(queryCourseParamsDto.getPublishStatus()), CourseBase::getStatus,queryCourseParamsDto.getPublishStatus()); //2.创建分页信息 Page\u0026lt;CourseBase\u0026gt; page=new Page\u0026lt;\u0026gt;(pageParams.getPageNo(), pageParams.getPageSize()); //3.查询数据库 Page\u0026lt;CourseBase\u0026gt; basePage = courseBaseMapper.selectPage(page, queryWrapper); //4.封装信息，返回数据 PageResult\u0026lt;CourseBase\u0026gt; pageResult = new PageResult\u0026lt;\u0026gt;(basePage.getRecords(), basePage.getTotal(), pageParams.getPageNo(), pageParams.getPageSize()); return pageResult; } } 测试Service 下边对service进行单元测试，编写单元测试类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package com.xuecheng.content; import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import com.xuecheng.base.model.PageParams; import com.xuecheng.base.model.PageResult; import com.xuecheng.content.mapper.CourseBaseMapper; import com.xuecheng.content.model.dto.QueryCourseParamsDto; import com.xuecheng.content.model.po.CourseBase; import com.xuecheng.content.service.CourseBaseService; import org.junit.jupiter.api.Assertions; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import javax.annotation.Resource; import java.util.List; /** * 课程基本信息测试类 */ @SpringBootTest public class CourseBaseServiceTests { @Autowired private CourseBaseService courseBaseService; @Test void testBaseService() { //查询条件 QueryCourseParamsDto queryCourseParamsDto =new QueryCourseParamsDto(); queryCourseParamsDto.setCourseName(\u0026#34;java\u0026#34;); queryCourseParamsDto.setAuditStatus(\u0026#34;202004\u0026#34;); //分页查询 PageParams page=new PageParams(1L,2L); PageResult\u0026lt;CourseBase\u0026gt; courseBasePageResult = courseBaseService.queryCourseBasePages(page, queryCourseParamsDto); System.out.println(\u0026#34;courseBasePageResult = \u0026#34; + courseBasePageResult); } } 接口测试 接口完善 控制层、业务层以及持久层三层通常可以面向接口并行开发，比如：业务层开发的同事可以先只编写一个Service接口，接口层的同事即可面向Service接口去开发，待接口层和业务层完成后进行连调。\n下边课程查询接口的实现。\n1 2 3 4 5 6 @ApiOperation(\u0026#34;课程查询接口\u0026#34;) @PostMapping(\u0026#34;/course/list\u0026#34;) public PageResult\u0026lt;CourseBase\u0026gt; list(PageParams pageParams, @RequestBody QueryCourseParamsDto queryCourseParams){ PageResult\u0026lt;CourseBase\u0026gt; pageResult = courseBaseInfoService.queryCourseBaseList(pageParams, queryCourseParams); return pageResult; } 再次打开Swagger进行测试，即可。\nHttpClient测试 Swagger是一个在线接口文档，虽然使用它也能测试但需要浏览器进入Swagger，最关键的是它并不能保存测试数据。在IDEA中有一个非常方便的http接口测试工具httpclient，下边介绍它的使用方法，后边我们会用它进行接口测试。如果IDEA版本较低没有自带httpclient，需要安装httpclient插件，在插件中搜索httpclient关键字即可。\nHttpClient测试使用方法：\n进入controller类，找到http接口对应的方法\n点击Generate request in HTTP Client即可生成的一个测试用例。\n可以看到自己生成了一个.http结尾的文件，可以添加请求参数进行测试。\n其中http的url下面要加上请求头，content-Type，一般都为：Content-Type: application/json。 然后空一行，添加json形式的请求参数即可。 然会直接测试即可，观察控制台是否运行顺利\n.http文件即测试用例文档 ，它可以随着项目工程一起保存，保存在项目的**.idea/httpRequests**目录下，这样测试的数据就可以保存下来，方便进行测试。\n为了方便保存**.http**文件 ，可以单独在项目工程的根目录创建一个目录单独存放它们。\n以模块为单位创建.http文件。 打开内容管理模块的 http文件 ，把刚才测试数据拷贝上去。 为了方便将来和网关集成测试，这里我们把测试主机地址在配置文件http-client.env.json 中配置。\n[!CAUTION]\n注意：文件名称http-client.env.json保持一致，否则无法读取dev环境变量的内容。\n内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;dev\u0026#34;: { \u0026#34;access_token\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;gateway_host\u0026#34;: \u0026#34;localhost:63010\u0026#34;, \u0026#34;content_host\u0026#34;: \u0026#34;localhost:63040\u0026#34;, \u0026#34;system_host\u0026#34;: \u0026#34;localhost:63110\u0026#34;, \u0026#34;media_host\u0026#34;: \u0026#34;localhost:63050\u0026#34;, \u0026#34;search_host\u0026#34;: \u0026#34;localhost:63080\u0026#34;, \u0026#34;auth_host\u0026#34;: \u0026#34;localhost:63070\u0026#34;, \u0026#34;checkcode_host\u0026#34;: \u0026#34;localhost:63075\u0026#34;, \u0026#34;learning_host\u0026#34;: \u0026#34;localhost:63020\u0026#34; } } 再回到xc-content-api.http文件，将http://localhost:63040 用变量代替，即可。\n前后端联调 准备环境 什么是前后端联调？\n通常由后端工程师将接口设计好并编写接口文档，将接口文档交给前端工程师，前后端的工程师就开始并行开发，前端开发人员会使用mock数据（假数据）进行开发，当前后端代码完成后开始进行接口联调，前端工程师将mock数据改为请求后端接口获取，前端代码请求后端服务测试接口是否正常，这个过程是前后端联调。\n当前后端联调出现问题需要根据测试环境下接口的请求及响应数据内容去判断是否符合接口文档的要求。查出是前端或后端的问题由具体的工程师负责修改缺陷，修改后再次回归测试。\n首先配置前端环境，下边安装前端工程运行的环境。从软件工具目录找到node-v16.17.0-x64.msi安装nodejs。\n[!WARNING]\n警告：若是已有nodejs，一定要注意版本，最好与黑马提供的版本一致，否则可能会运行失败，这里我就使因为版本不一致，导致失败，最后重装了老师的版本。\n安装完成，查看版本号\n下边启动前端工程，从前端工程拷贝project-xczx2-portal-vue-ts.zip到代码目录并解压，并使用IDEA或VS Code打开project-xczx2-portal-vue-ts目录，这里以VS Code为例：\n在VS Code中打开终端运行以下命令即可\n1 2 3 npm install -g npm i npm run serve 安装系统管理服务 启动前端工程成功，在浏览器通过http://localhost:8601/地址访问前端工程。前端工程报错如下：\nhttp://localhost:8601/system/dictionary/all 指向的是系统管理服务。在前面讲解内容管理模块的需求时我们提到一个数据字典表，此链接正是在前端请求后端获取数据字典数据的接口地址。 数据字典表中配置了项目用的字典信息，此接口是查询字典中的全部数据 ，在此我们不再开发，按照下边的步骤安装系统管理服务即可。 从课程资料/项目工程目录获取xuecheng-plus-system.zip，并解压将xuecheng-plus-system目录拷贝到项目工程根目录，刷新maven，或进入pom.xml右键转为pom工程。 进入xuecheng-plus-system-service工程，找到resources下的application.yml修改数据库连接参数。启动系统管理服务，启动成功，在浏览器请求：http://localhost:63110/system/dictionary/all系统服务的端口是63110如果可以正常读取数据字典信息则说明系统管理服务安装成功。 解决跨域问题 在浏览器通过http://localhost:8601/地址访问前端工程。\nfirefox浏览器报错如下：\n1 已拦截跨源请求：同源策略禁止读取位于 http://localhost:63110/system/dictionary/all 的远程资源。（原因：CORS 头缺少 \u0026#39;Access-Control-Allow-Origin\u0026#39;）。状态码：200。 从http://localhost:8601访问http://localhost:63110/system/dictionary/all被CORS policy阻止，因为没有Access-Control-Allow-Origin 头信息。CORS全称是 cross origin resource share 表示跨域资源共享。\n出这个提示的原因是基于浏览器的同源策略，去判断是否跨域请求，同源策略是浏览器的一种安全机制，从一个地址请求另一个地址，如果协议、主机、端口三者全部一致则不属于跨域，否则有一个不一致就是跨域请求。比如：\n从http://localhost:8601 到 http://localhost:8602 由于端口不同，是跨域。\n从http://192.168.101.10:8601 到 http://192.168.101.11:8601 由于主机不同，是跨域。\n从http://192.168.101.10:8601 到 https://192.168.101.10:8601 由于协议不同，是跨域。\n[!CAUTION]\n注意：服务器之间不存在跨域请求。\n浏览器判断是跨域请求会在请求头上添加origin，表示这个请求来源哪里。比如：\n1 2 GET / HTTP/1.1 Origin: http://localhost:8601 服务器收到请求判断这个Origin是否允许跨域，如果允许则在响应头中说明允许该来源的跨域请求，如下：\n1 Access-Control-Allow-Origin：http://localhost:8601 如果允许任何域名来源的跨域请求，则响应如下：\n1 Access-Control-Allow-Origin：* 解决跨域的方法：\nJSONP\n通过script标签的src属性进行跨域请求，如果服务端要响应内容则首先读取请求参数callback的值，callback是一个回调函数的名称，服务端读取callback的值后将响应内容通过调用callback函数的方式告诉请求方。如下图：\n添加响应头\n服务端在响应头添加 Access-Control-Allow-Origin：* 通过nginx代理跨域\n由于服务端之间没有跨域，浏览器通过nginx去访问跨域地址。\n浏览器先访问http://192.168.101.10:8601 nginx提供的地址，进入页面 此页面要跨域访问http://192.168.101.11:8601 ，不能直接跨域访问http://www.baidu.com:8601 ，而是访问nginx的一个同源地址，比如：http://192.168.101.11:8601/api ，通过http://192.168.101.11:8601/api 的代理去访问http://www.baidu.com:8601。这样就实现了跨域访问。 浏览器到http://192.168.101.11:8601/api 没有跨域。nginx到http://www.baidu.com:8601通过服务端通信，没有跨域。 本项目使用方案2解决跨域问题。在内容管理的api工程config包下编写GlobalCorsConfig.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.xuecheng.system.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.web.filter.CorsFilter; /** * @description 跨域过虑器 */ @Configuration public class GlobalCorsConfig { /** * 允许跨域调用的过滤器 */ @Bean public CorsFilter corsFilter() { CorsConfiguration config = new CorsConfiguration(); //允许白名单域名进行跨域调用 config.addAllowedOrigin(\u0026#34;*\u0026#34;); //允许跨越发送cookie config.setAllowCredentials(true); //放行全部原始头信息 config.addAllowedHeader(\u0026#34;*\u0026#34;); //允许所有请求方法跨域调用 config.addAllowedMethod(\u0026#34;*\u0026#34;); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026#34;/**\u0026#34;, config); return new CorsFilter(source); } } 此配置类实现了跨域过虑器，在响应头添加Access-Control-Allow-Origin。\n重启系统管理服务，前端工程可以正常进入http://localhost:8601，观察浏览器记录，成功解决跨域。\n前后端联调 这里进行前后联调的目的是体会前后端联调的流程，测试的功能为课程查询功能。\n启动前端工程，再启内容管理服务端。 修改服务端地址 前端默认连接的是项目的网关地址，由于现在网关工程还没有创建，这里需要更改前端工程的参数配置文件 ，修改网关地址为内容管理服务的地址。 将下图最后一个地址打开，其他注释即可。\n启动前端工程，用前端访问后端接口，观察前端界面的数据是否正确。\n访问前端首页，进入课程管理：http://localhost:8601/#/organization/course-list。\n更改课程条件及分页参数测试课程查询列表是否正常显示。 跟踪内容管理服务的输出日志，查看是否正常。 课程分类查询 需求分析 下边根据内容管理模块的业务流程，下一步要实现新增课程，在新增课程界面，有三处信息需要选择，如下图：\n课程等级、课程类型来源于数据字典表，此部分的信息前端已从系统管理服务读取。\n课程分类信息没有在数据字典表中存储，而是由单独一张课程分类表，存储在内容管理数据库中，需要编写一个接口获取。\n这张表是一个树型结构，通过父结点id将各元素组成一个树。下图是一部分数据：\n现在的需求是：需要在内容管理服务中编写一个接口读取该课程分类表的数据，组成一个树型结构返回给前端。\n接口定义 通过点击新增课程，可以观察前端的请求记录为：\n1 2 3 4 请求网址: http://localhost:8601/api/content/course-category/tree-nodes 请求方法: GET 状态代码: 404 Not Found 远程地址: 127.0.0.1:8601 通过查阅接口文档，此接口要返回全部课程分类，以树型结构返回，如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 [ { \u0026#34;childrenTreeNodes\u0026#34;: [ { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-1\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;HTML/CSS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;HTML/CSS\u0026#34;, \u0026#34;orderby\u0026#34;: 1, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-2\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;JavaScript\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;JavaScript\u0026#34;, \u0026#34;orderby\u0026#34;: 2, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-3\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;jQuery\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;jQuery\u0026#34;, \u0026#34;orderby\u0026#34;: 3, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-4\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;ExtJS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;ExtJS\u0026#34;, \u0026#34;orderby\u0026#34;: 4, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-5\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;AngularJS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;AngularJS\u0026#34;, \u0026#34;orderby\u0026#34;: 5, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-6\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;ReactJS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;ReactJS\u0026#34;, \u0026#34;orderby\u0026#34;: 6, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-7\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;Bootstrap\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Bootstrap\u0026#34;, \u0026#34;orderby\u0026#34;: 7, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-8\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;Node.js\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Node.js\u0026#34;, \u0026#34;orderby\u0026#34;: 8, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-9\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;Vue\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Vue\u0026#34;, \u0026#34;orderby\u0026#34;: 9, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-1-10\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;其它\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;其它\u0026#34;, \u0026#34;orderby\u0026#34;: 10, \u0026#34;parentid\u0026#34;: \u0026#34;1-1\u0026#34; } ], \u0026#34;id\u0026#34;: \u0026#34;1-1\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;前端开发\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;前端开发\u0026#34;, \u0026#34;orderby\u0026#34;: 1, \u0026#34;parentid\u0026#34;: \u0026#34;1\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: [ { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-2-1\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;微信开发\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;微信开发\u0026#34;, \u0026#34;orderby\u0026#34;: 1, \u0026#34;parentid\u0026#34;: \u0026#34;1-2\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-2-2\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;iOS\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;iOS\u0026#34;, \u0026#34;orderby\u0026#34;: 2, \u0026#34;parentid\u0026#34;: \u0026#34;1-2\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-2-3\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;手游开发\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;手游开发\u0026#34;, \u0026#34;orderby\u0026#34;: 3, \u0026#34;parentid\u0026#34;: \u0026#34;1-2\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-2-4\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;Swift\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Swift\u0026#34;, \u0026#34;orderby\u0026#34;: 4, \u0026#34;parentid\u0026#34;: \u0026#34;1-2\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-2-5\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;Android\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Android\u0026#34;, \u0026#34;orderby\u0026#34;: 5, \u0026#34;parentid\u0026#34;: \u0026#34;1-2\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-2-6\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;ReactNative\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;ReactNative\u0026#34;, \u0026#34;orderby\u0026#34;: 6, \u0026#34;parentid\u0026#34;: \u0026#34;1-2\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-2-7\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;Cordova\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Cordova\u0026#34;, \u0026#34;orderby\u0026#34;: 7, \u0026#34;parentid\u0026#34;: \u0026#34;1-2\u0026#34; }, { \u0026#34;childrenTreeNodes\u0026#34;: null, \u0026#34;id\u0026#34;: \u0026#34;1-2-8\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;其它\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;其它\u0026#34;, \u0026#34;orderby\u0026#34;: 8, \u0026#34;parentid\u0026#34;: \u0026#34;1-2\u0026#34; } ], \u0026#34;id\u0026#34;: \u0026#34;1-2\u0026#34;, \u0026#34;isLeaf\u0026#34;: null, \u0026#34;isShow\u0026#34;: null, \u0026#34;label\u0026#34;: \u0026#34;移动开发\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;移动开发\u0026#34;, \u0026#34;orderby\u0026#34;: 2, \u0026#34;parentid\u0026#34;: \u0026#34;1\u0026#34; } ] 上边的数据格式是一个数组结构，数组的元素即为分类信息，分类信息设计两级分类，第一级的分类信息示例如下：\n1 2 3 4 5 6 7 \u0026#34;id\u0026#34; : \u0026#34;1-2\u0026#34;, \u0026#34;isLeaf\u0026#34; : null, \u0026#34;isShow\u0026#34; : null, \u0026#34;label\u0026#34; : \u0026#34;移动开发\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;移动开发\u0026#34;, \u0026#34;orderby\u0026#34; : 2, \u0026#34;parentid\u0026#34; : \u0026#34;1\u0026#34; 第二级的分类是第一级分类中childrenTreeNodes属性，它是一个数组结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \u0026#34;id\u0026#34; : \u0026#34;1-2\u0026#34;, \u0026#34;isLeaf\u0026#34; : null, \u0026#34;isShow\u0026#34; : null, \u0026#34;label\u0026#34; : \u0026#34;移动开发\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;移动开发\u0026#34;, \u0026#34;orderby\u0026#34; : 2, \u0026#34;parentid\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;childrenTreeNodes\u0026#34; : [ { \u0026#34;childrenTreeNodes\u0026#34; : null, \u0026#34;id\u0026#34; : \u0026#34;1-2-1\u0026#34;, \u0026#34;isLeaf\u0026#34; : null, \u0026#34;isShow\u0026#34; : null, \u0026#34;label\u0026#34; : \u0026#34;微信开发\u0026#34;, \u0026#34;name\u0026#34; : \u0026#34;微信开发\u0026#34;, \u0026#34;orderby\u0026#34; : 1, \u0026#34;parentid\u0026#34; : \u0026#34;1-2\u0026#34; } } 所以，在com.xuecheng.content.model.dto包下定义一个DTO类表示分类信息的模型类，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package com.xuecheng.content.model.dto; import com.xuecheng.content.model.po.CourseCategory; import lombok.Data; import java.io.Serializable; import java.util.List; @Data public class CourseCategoryTreeDto extends CourseCategory implements Serializable { List\u0026lt;CourseCategoryTreeDto\u0026gt; childrenTreeNodes; } 接口定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.xuecheng.content.api; import com.xuecheng.content.model.dto.CourseCategoryTreeDto; import com.xuecheng.content.service.CourseCategoryService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; /** * \u0026lt;p\u0026gt; * 数据字典 前端控制器 * \u0026lt;/p\u0026gt; * * @author itcast */ @Slf4j @RestController public class CourseCategoryController { @GetMapping(\u0026#34;/course-category/tree-nodes\u0026#34;) public List\u0026lt;CourseCategoryTreeDto\u0026gt; queryTreeNodes() { return null; } } 接口开发 树型表查询 课程分类表是一个树型结构，其中parentid字段为父结点ID，它是树型结构的标志字段。下面有两种查询方法\n如果树的层级固定可以使用表的自链接去查询，比如：我们只查询两级课程分类，可以用下边的SQL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 select one.id one_id, one.name one_name, one.parentid one_parentid, one.orderby one_orderby, one.label one_label, two.id two_id, two.name two_name, two.parentid two_parentid, two.orderby two_orderby, two.label two_label from course_category one inner join course_category two on one.id = two.parentid where one.parentid = 1 and one.is_show = 1 and two.is_show = 1 order by one.orderby, two.orderby 如果树的层级不确定，此时可以使用MySQL递归实现，使用with语法，如下：\n1 2 3 WITH [RECURSIVE] cte_name [(col_name [, col_name] ...)] AS (subquery) [, cte_name [(col_name [, col_name] ...)] AS (subquery)] ... cte_name :公共表达式的名称,可以理解为表名,用来表示as后面跟着的子查询\ncol_name :公共表达式包含的列名,可以写也可以不写\n下边是一个递归的简单例子：\n1 2 3 4 5 6 7 with RECURSIVE t1 AS ( SELECT 1 as n UNION ALL SELECT n + 1 FROM t1 WHERE n \u0026lt; 5 ) SELECT * FROM t1; 说明：\nt1 相当于一个表名\nselect 1 相当于这个表的初始值，这里使用UNION ALL 不断将每次递归得到的数据加入到表中。\nn\u0026lt;5为递归执行的条件，当n\u0026gt;=5时结束递归调用。\n使用递归实现课程分类的查询\n1 2 3 4 5 6 with recursive t1 as ( select * from course_category p where id= \u0026#39;1\u0026#39; union all select t.* from course_category t inner join t1 on t1.id = t.parentid ) select * from t1 order by t1.id, t1.orderby with recursive t1 as：定义了一个递归 CTE，名称为 t1。\n第一个 select：选择了 course_category 表中 id 为 \u0026lsquo;1\u0026rsquo; 的记录。这通常是树形结构中的某个节点（父节点）。\nunion all：用于将两个查询的结果合并在一起，并保留重复的行（如果有的话）。\n第二个 select：这部分是核心的递归查询，它从 course_category 表中选择所有与 t1 中的结果通过 parentid 关联的记录。这意味着，它会找到所有直接子类别（将 t1 中的每一条记录与其在 course_category 中的子项进行匹配）。\nselect * from t1：从 CTE t1 中选择所有记录，即选择了 id 为 \u0026lsquo;1\u0026rsquo; 的记录及其所有子记录（级联）。\norder by t1.id, t1.orderby\n：这条命令将结果按照两个字段排序：\n首先按 id 排序。 然后按 orderby 排序，通常用于确定顺序展示的字段。 查询结果如下：\n上边这种方法是向下递归，即找到初始节点的所有下级节点。如何向上递归？\n下边的sql实现了向上递归：\n1 2 3 4 5 6 with recursive t1 as ( select * from course_category p where id= \u0026#39;1-1-1\u0026#39; union all select t.* from course_category t inner join t1 on t1.parentid = t.id ) select * from t1 order by t1.id, t1.orderby 初始节点为1-1-1，通过递归找到它的父级节点，父级节点包括所有级别的节点。\nmysql为了避免无限递归默认递归次数为1000，可以通过设置cte_max_recursion_depth参数增加递归深度，还可以通过max_execution_time限制执行时间，超过此时间也会终止递归操作。\nmysql递归相当于在存储过程中执行若干次sql语句，java程序仅与数据库建立一次链接执行递归操作，所以只要控制好递归深度，控制好数据量性能就没有问题。\n开发Mapper 下边我们可自定义mapper方法查询课程分类，最终将查询结果映射到List中。\n定义一个mapper方法，并定义sql语句。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.xuecheng.content.mapper; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.xuecheng.content.model.dto.CourseCategoryTreeDto; import com.xuecheng.content.model.po.CourseCategory; import java.util.List; /** * \u0026lt;p\u0026gt; * 课程分类 Mapper 接口 * \u0026lt;/p\u0026gt; * * @author itcast */ public interface CourseCategoryMapper extends BaseMapper\u0026lt;CourseCategory\u0026gt; { //使用递归查询课程分类 public List\u0026lt;CourseCategoryTreeDto\u0026gt; childrenTreeNodes(String id); } 找到对应 的mapper.xml文件，编写sql语句。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;select id=\u0026#34;childrenTreeNodes\u0026#34; resultType=\u0026#34;com.xuecheng.content.model.dto.CourseCategoryTreeDto\u0026#34; parameterType=\u0026#34;java.lang.String\u0026#34;\u0026gt; with recursive categorys as ( select * from course_category where id =#{id} union all select c1.* from course_category c1 inner join categorys c2 on c2.id=c1.parentid ) select * from categorys order by categorys.id \u0026lt;/select\u0026gt; 开发Service 定义service接口，调用mapper查询课程分类，遍历数据按照接口要求对数据进行封装\n1 2 3 4 5 6 7 8 public interface CourseCategoryService { /** * 课程分类树形结构查询 * * @return */ public List\u0026lt;CourseCategoryTreeDto\u0026gt; queryTreeNodes(String id); } 编写service接口实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 @Service public class CourseCategoryServiceImpl implements CourseCategoryService { @Autowired private CourseCategoryMapper courseCategoryMapper; @Override public List\u0026lt;CourseCategoryTreeDto\u0026gt; queryTreeNode(String id) { //1.递归查询分类信息 List\u0026lt;CourseCategoryTreeDto\u0026gt; categoryTreeDtoList = courseCategoryMapper.childrenTreeNodes(id); //2.找到每个节点的子节点进行数据的封装 //2.1将list转为map方便后面根据parentId查询父节点 //filter(item-\u0026gt;!id.equals(item.getId()))用于过滤根节点 Map\u0026lt;String, CourseCategoryTreeDto\u0026gt; categoryTreeDtoMap = categoryTreeDtoList.stream().filter(item-\u0026gt;!id.equals(item.getId())) .collect(Collectors.toMap(key -\u0026gt; key.getId(), value -\u0026gt; value, (key1, key2) -\u0026gt; key2)); //2.2找到每个节点的父节点，并放入父节点的childrenTreeNodes中 List\u0026lt;CourseCategoryTreeDto\u0026gt; resultList=new ArrayList\u0026lt;\u0026gt;(); categoryTreeDtoList.stream().forEach(item-\u0026gt;{ //2.2.1判断该节点是否时根节点的子节点 if(id.equals(item.getParentid())){ //是，放入resultList中 resultList.add(item); }else{ //2.2.2不是，找到该节点的父节点 CourseCategoryTreeDto categoryTreeParent = categoryTreeDtoMap.get(item.getParentid()); //2.2.2.1判断其父节点是否为null，预防空指针 if(categoryTreeParent!=null){ //2.2.2.2判断其父节点的CourseCategoryTreeDto是否为空 if(categoryTreeParent.getChildrenTreeNodes()==null){ //2.2.2.3为空，new一个并为其复制 categoryTreeParent.setChildrenTreeNodes(new ArrayList\u0026lt;CourseCategoryTreeDto\u0026gt;()); } //2.2.2.4将其添加到父节点的CourseCategoryTreeDto中 categoryTreeParent.getChildrenTreeNodes().add(item); } } }); return resultList; } } 单元测试 定义单元测试类对service接口进行测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @SpringBootTest class CourseCategoryServiceTests { @Autowired CourseCategoryService courseCategoryService; @Test void testqueryTreeNodes() { List\u0026lt;CourseCategoryTreeDto\u0026gt; categoryTreeDtos = courseCategoryService.queryTreeNodes(\u0026#34;1\u0026#34;); System.out.println(categoryTreeDtos); } } 接口测试 接口层代码完善 完善controller方法，注入service调用业务层方法查询课程分类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * \u0026lt;p\u0026gt; * 数据字典 前端控制器 * \u0026lt;/p\u0026gt; * * @author itcast */ @Slf4j @RestController public class CourseCategoryController { @Autowired CourseCategoryService courseCategoryService; @GetMapping(\u0026#34;/course-category/tree-nodes\u0026#34;) public List\u0026lt;CourseCategoryTreeDto\u0026gt; queryTreeNodes() { return courseCategoryService.queryTreeNodes(\u0026#34;1\u0026#34;); } } 测试接口 使用httpclient测试： 完成前后端连调：\n打开前端工程，进入新增课程页面。\n课程分类下拉框可以正常显示\n新增课程 需求分析 业务流程 根据前边对内容管理模块的数据模型分析，课程相关的信息有：课程基本信息、课程营销信息、课程图片信息、课程计划、课程师资信息，所以新增一门课程需要完成这几部分信息的填写。\n以下是业务流程：\n进入课程查询列表\n点击添加课程，选择课程形式为录播。\n选择完毕，点击下一步，进入课程基本信息添加界面。\n本界面分两部分信息，一部分是课程基本信息上，一部分是课程营销信息。 在此界面填写课程计划信息\n课程计划即课程的大纲目录。\n课程计划分为两级，章节和小节。\n每个小节需要上传课程视频，用户点击 小节的标题即开始播放视频。\n如果是直播课程则会进入直播间。\n课程计划填写完毕进入课程师资的管理。\n在课程师资界面维护该课程的授课老师。 数据模型 通过业务流程可知，一门课程信息涉及：课程基本信息、课程营销信息、课程计划信息、课程师资信息。\n本节开发新增课程按钮功能， 只向课程基本信息、课程营销信息添加记录。\n这两部分信息分别在course_base、course_market两张表存储。当点击保存按钮时向这两张表插入数据。这两张表是一对一关联关系。\n课程基本信息：\n课程营销信息表：\n接口定义 根据业务流程，这里先定义提交课程基本信息的接口。\n1 2 3 4 请求网址: http://localhost:8601/api/content/course 请求方法: POST 状态代码: 404 Not Found 远程地址: 127.0.0.1:8601 接口请求示例如下 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ### 创建课程 POST {{content_host}}/content/course Content-Type: application/json ###请求参数如下 { \u0026#34;mt\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;st\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;teachmode\u0026#34;: \u0026#34;200002\u0026#34;, \u0026#34;users\u0026#34;: \u0026#34;初级人员\u0026#34;, \u0026#34;tags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;grade\u0026#34;: \u0026#34;204001\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;charge\u0026#34;: \u0026#34;201000\u0026#34;, \u0026#34;price\u0026#34;: 0, \u0026#34;originalPrice\u0026#34;:0, \u0026#34;qq\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;wechat\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;validDays\u0026#34;: 365 } ###响应结果如下 #成功响应结果如下 { \u0026#34;id\u0026#34;: 109, \u0026#34;companyId\u0026#34;: 1, \u0026#34;companyName\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;测试课程103\u0026#34;, \u0026#34;users\u0026#34;: \u0026#34;初级人员\u0026#34;, \u0026#34;tags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;mt\u0026#34;: \u0026#34;1-1\u0026#34;, \u0026#34;mtName\u0026#34;: null, \u0026#34;st\u0026#34;: \u0026#34;1-1-1\u0026#34;, \u0026#34;stName\u0026#34;: null, \u0026#34;grade\u0026#34;: \u0026#34;204001\u0026#34;, \u0026#34;teachmode\u0026#34;: \u0026#34;200002\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;pic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;createDate\u0026#34;: \u0026#34;2022-09-08 07:35:16\u0026#34;, \u0026#34;changeDate\u0026#34;: null, \u0026#34;createPeople\u0026#34;: null, \u0026#34;changePeople\u0026#34;: null, \u0026#34;auditStatus\u0026#34;: \u0026#34;202002\u0026#34;, \u0026#34;status\u0026#34;: 1, \u0026#34;coursePubId\u0026#34;: null, \u0026#34;coursePubDate\u0026#34;: null, \u0026#34;charge\u0026#34;: \u0026#34;201000\u0026#34;, \u0026#34;price\u0026#34;: null, \u0026#34;originalPrice\u0026#34;:0, \u0026#34;qq\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;wechat\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;validDays\u0026#34;: 365 } 定义请求参数类型和响应结构类型\n根据接口定义内容，请求参数相比 CourseBase模型类不一致，需要在dto包下自定义。\n请求参数模型类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * @description 添加课程dto(添加课程基本信息时的请求参数) * @version 1.0 */ @Data @ApiModel(value=\u0026#34;AddCourseDto\u0026#34;, description=\u0026#34;新增课程基本信息\u0026#34;) public class AddCourseDto { // @NotEmpty(message = \u0026#34;新增课程名称不能为空\u0026#34;,groups = ValidationGroups.Insert.class) @NotEmpty(message = \u0026#34;课程名称不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;课程名称\u0026#34;, required = true) private String name; @NotEmpty(message = \u0026#34;适用人群不能为空\u0026#34;) @Size(message = \u0026#34;适用人群内容过少\u0026#34;,min = 10) @ApiModelProperty(value = \u0026#34;适用人群\u0026#34;, required = true) private String users; @ApiModelProperty(value = \u0026#34;课程标签\u0026#34;) private String tags; @NotEmpty(message = \u0026#34;课程分类不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;大分类\u0026#34;, required = true) private String mt; @NotEmpty(message = \u0026#34;课程分类不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;小分类\u0026#34;, required = true) private String st; @NotEmpty(message = \u0026#34;课程等级不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;课程等级\u0026#34;, required = true) private String grade; @ApiModelProperty(value = \u0026#34;教学模式（普通，录播，直播等）\u0026#34;, required = true) private String teachmode; @ApiModelProperty(value = \u0026#34;课程介绍\u0026#34;) private String description; @ApiModelProperty(value = \u0026#34;课程图片\u0026#34;, required = true) private String pic; @NotEmpty(message = \u0026#34;收费规则不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;收费规则，对应数据字典\u0026#34;, required = true) private String charge; @ApiModelProperty(value = \u0026#34;价格\u0026#34;) private Float price; @ApiModelProperty(value = \u0026#34;原价\u0026#34;) private Float originalPrice; @ApiModelProperty(value = \u0026#34;qq\u0026#34;) private String qq; @ApiModelProperty(value = \u0026#34;微信\u0026#34;) private String wechat; @ApiModelProperty(value = \u0026#34;电话\u0026#34;) private String phone; @ApiModelProperty(value = \u0026#34;有效期\u0026#34;) private Integer validDays; } 响应结果模型类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /** * @description 课程基本信息dto * @version 1.0 */ @Data public class CourseBaseInfoDto extends CourseBase { /** * 收费规则，对应数据字典 */ private String charge; /** * 价格 */ private Float price; /** * 原价 */ private Float originalPrice; /** * 咨询qq */ private String qq; /** * 微信 */ private String wechat; /** * 电话 */ private String phone; /** * 有效期天数 */ private Integer validDays; /** * 大分类名称 */ private String mtName; /** * 小分类名称 */ private String stName; } 接口定义\n1 2 3 4 5 @ApiOperation(\u0026#34;新增课程基础信息\u0026#34;) @PostMapping(\u0026#34;/course\u0026#34;) public CourseBaseInfoDto createCourseBase(@RequestBody AddCourseDto addCourseDto){ return null; } 接口开发 根据需求分析，新增课程表单中包括了课程基本信息、课程营销信息，需要分别向课程基本信息表、课程营销表保证数据。\n首先定义service接口\n1 2 3 4 5 6 7 /** * @description 添加课程基本信息 * @param companyId 教学机构id * @param addCourseDto 课程基本信息 * @return */ CourseBaseInfoDto createCourseBase(Long companyId,AddCourseDto addCourseDto); 编写service接口实现类，实现向课程基本信息表和课程营销表中保存数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 public CourseBaseInfoDto createCourseBase(Long companyId, AddCourseDto dto) { //合法性校验 if (StringUtils.isBlank(dto.getName())) { throw new RuntimeException(\u0026#34;课程名称为空\u0026#34;); } if (StringUtils.isBlank(dto.getMt())) { throw new RuntimeException(\u0026#34;课程分类为空\u0026#34;); } if (StringUtils.isBlank(dto.getSt())) { throw new RuntimeException(\u0026#34;课程分类为空\u0026#34;); } if (StringUtils.isBlank(dto.getGrade())) { throw new RuntimeException(\u0026#34;课程等级为空\u0026#34;); } if (StringUtils.isBlank(dto.getTeachmode())) { throw new RuntimeException(\u0026#34;教育模式为空\u0026#34;); } if (StringUtils.isBlank(dto.getUsers())) { throw new RuntimeException(\u0026#34;适应人群为空\u0026#34;); } if (StringUtils.isBlank(dto.getCharge())) { throw new RuntimeException(\u0026#34;收费规则为空\u0026#34;); } //新增对象 CourseBase courseBaseNew = new CourseBase(); //将填写的课程信息赋值给新增对象 BeanUtils.copyProperties(dto,courseBaseNew); //设置审核状态 courseBaseNew.setAuditStatus(\u0026#34;202002\u0026#34;); //设置发布状态 courseBaseNew.setStatus(\u0026#34;203001\u0026#34;); //机构id courseBaseNew.setCompanyId(companyId); //添加时间 courseBaseNew.setCreateDate(LocalDateTime.now()); //插入课程基本信息表 int insert = courseBaseMapper.insert(courseBaseNew); if(insert\u0026lt;=0){ throw new RuntimeException(\u0026#34;新增课程基本信息失败\u0026#34;); } //向课程营销表保存课程营销信息 //课程营销信息 CourseMarket courseMarketNew = new CourseMarket(); Long courseId = courseBaseNew.getId(); BeanUtils.copyProperties(dto,courseMarketNew); courseMarketNew.setId(courseId); int i = saveCourseMarket(courseMarketNew); if(i\u0026lt;=0){ throw new RuntimeException(\u0026#34;保存课程营销信息失败\u0026#34;); } //查询课程基本信息及营销信息并返回 return getCourseBaseInfo(courseId); } //保存课程营销信息 private int saveCourseMarket(CourseMarket courseMarketNew){ //收费规则 String charge = courseMarketNew.getCharge(); if(StringUtils.isBlank(charge)){ throw new RuntimeException(\u0026#34;收费规则没有选择\u0026#34;); } //收费规则为收费 if(charge.equals(\u0026#34;201001\u0026#34;)){ if(courseMarketNew.getPrice() == null || courseMarketNew.getPrice().floatValue()\u0026lt;=0){ throw new RuntimeException(\u0026#34;课程为收费价格不能为空且必须大于0\u0026#34;); } } //根据id从课程营销表查询 CourseMarket courseMarketObj = courseMarketMapper.selectById(courseMarketNew.getId()); if(courseMarketObj == null){ return courseMarketMapper.insert(courseMarketNew); }else{ BeanUtils.copyProperties(courseMarketNew,courseMarketObj); courseMarketObj.setId(courseMarketNew.getId()); return courseMarketMapper.updateById(courseMarketObj); } } //根据课程id查询课程基本信息，包括基本信息和营销信息 public CourseBaseInfoDto getCourseBaseInfo(long courseId){ CourseBase courseBase = courseBaseMapper.selectById(courseId); if(courseBase == null){ return null; } CourseMarket courseMarket = courseMarketMapper.selectById(courseId); CourseBaseInfoDto courseBaseInfoDto = new CourseBaseInfoDto(); BeanUtils.copyProperties(courseBase,courseBaseInfoDto); if(courseMarket != null){ BeanUtils.copyProperties(courseMarket,courseBaseInfoDto); } //查询分类名称 CourseCategory courseCategoryBySt = courseCategoryMapper.selectById(courseBase.getSt()); courseBaseInfoDto.setStName(courseCategoryBySt.getName()); CourseCategory courseCategoryByMt = courseCategoryMapper.selectById(courseBase.getMt()); courseBaseInfoDto.setMtName(courseCategoryByMt.getName()); return courseBaseInfoDto; } 接口测试 完成controller方法\n1 2 3 4 5 6 7 @ApiOperation(\u0026#34;新增课程基础信息\u0026#34;) @PostMapping(\u0026#34;/course\u0026#34;) public CourseBaseInfoDto createCourseBase(@RequestBody AddCourseDto addCourseDto){ //机构id，由于认证系统没有上线暂时硬编码 Long companyId = 1232141425L; return courseBaseInfoService.createCourseBase(companyId,addCourseDto); } 使用httpclient测试\n在xc-content-api.http中定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ### 创建课程 POST {{content_host}}/content/course Content-Type: application/json { \u0026#34;charge\u0026#34;: \u0026#34;201000\u0026#34;, \u0026#34;price\u0026#34;: 0, \u0026#34;originalPrice\u0026#34;:0, \u0026#34;qq\u0026#34;: \u0026#34;22333\u0026#34;, \u0026#34;wechat\u0026#34;: \u0026#34;223344\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;13333333\u0026#34;, \u0026#34;validDays\u0026#34;: 365, \u0026#34;mt\u0026#34;: \u0026#34;1-1\u0026#34;, \u0026#34;st\u0026#34;: \u0026#34;1-1-1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;测试课程103\u0026#34;, \u0026#34;pic\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;teachmode\u0026#34;: \u0026#34;200002\u0026#34;, \u0026#34;users\u0026#34;: \u0026#34;初级人员\u0026#34;, \u0026#34;tags\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;grade\u0026#34;: \u0026#34;204001\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34; } 前后端联调\n打开新增课程页面，除了课程图片其它信息全部输入。\n点击保存，观察浏览器请求接口参数及响应结果是否正常。\n异常处理 异常问题分析 在service方法中有很多的参数合法性校验，当参数不合法则抛出异常，下边我们测试下异常处理。例如：请求创建课程基本信息，故意将必填项设置为空。测试发现报500异常，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 http://localhost:63040/content/course HTTP/1.1 500 Content-Type: application/json Transfer-Encoding: chunked Date: Wed, 07 Sep 2022 11:40:29 GMT Connection: close { \u0026#34;timestamp\u0026#34;: \u0026#34;2022-09-07T11:40:29.677+00:00\u0026#34;, \u0026#34;status\u0026#34;: 500, \u0026#34;error\u0026#34;: \u0026#34;Internal Server Error\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/content/course\u0026#34; } 现存问题：并没有输出我们抛出异常时指定的异常信息。\n所以，现在我们的需求是当正常操作时按接口要求返回数据，当非正常流程时要获取异常信息进行记录，并提示给用户。\n异常处理除了输出在日志中，还需要提示给用户，前端和后端需要作一些约定：\n错误提示信息统一以json格式返回给前端。 以HTTP状态码决定当前是否出错，非200为操作异常。 如何规范异常信息？\n代码中统一抛出项目的自定义异常类型，这样可以统一去捕获这一类或几类的异常。\n规范了异常类型就可以去获取异常信息。\n如果捕获了非项目自定义的异常类型统一向用户提示“执行过程异常，请重试”的错误信息。\n如何捕获异常？\n代码统一用try/catch方式去捕获代码比较臃肿，可以通过SpringMVC提供的控制器增强类统一由一个类去完成异常的捕获。\n如下图：\n统一异常处理实现 根据上边分析的方案，统一在base基础工程实现统一异常处理，各模块依赖了base基础工程都可以使用。\n实现步骤如下：\n首先在base基础工程添加需要依赖的包：\n1 2 3 4 5 6 7 8 9 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 定义一些通用的异常信息(在com.xuecheng.base.execption定义枚举类)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.xuecheng.base.execption; /** * @description 通用错误信息 * @version 1.0 */ public enum CommonError { UNKOWN_ERROR(\u0026#34;执行过程异常，请重试。\u0026#34;), PARAMS_ERROR(\u0026#34;非法参数\u0026#34;), OBJECT_NULL(\u0026#34;对象为空\u0026#34;), QUERY_NULL(\u0026#34;查询结果为空\u0026#34;), REQUEST_NULL(\u0026#34;请求参数为空\u0026#34;); private String errMessage; public String getErrMessage() { return errMessage; } private CommonError( String errMessage) { this.errMessage = errMessage; } } 自定义异常类型，在base工程com.xuecheng.base.execption下自定义异常类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.xuecheng.base.execption; /** * @description 学成在线项目异常类 * @version 1.0 */ public class XueChengPlusException extends RuntimeException { private String errMessage; public XueChengPlusException() { super(); } public XueChengPlusException(String errMessage) { super(errMessage); this.errMessage = errMessage; } public String getErrMessage() { return errMessage; } public static void cast(CommonError commonError){ throw new XueChengPlusException(commonError.getErrMessage()); } public static void cast(String errMessage){ throw new XueChengPlusException(errMessage); } } 响应用户的统一类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.xuecheng.base.execption; import java.io.Serializable; /** * 错误响应参数包装 */ public class RestErrorResponse implements Serializable { private String errMessage; public RestErrorResponse(String errMessage){ this.errMessage= errMessage; } public String getErrMessage() { return errMessage; } public void setErrMessage(String errMessage) { this.errMessage = errMessage; } } 全局异常处理器\n从 Spring 3.0 - Spring 3.2 版本之间，对 Spring 架构和 SpringMVC 的Controller 的异常捕获提供了相应的异常处理。\n@ExceptionHandler Spring3.0提供的标识在方法上或类上的注解，用来表明方法的处理异常类型。 @ControllerAdvice Spring3.2提供的新注解，从名字上可以看出大体意思是控制器增强，在项目中来增强SpringMVC中的Controller。通常和**@ExceptionHandler** 结合使用，来处理SpringMVC的异常信息。 @ResponseStatus Spring3.0提供的标识在方法上或类上的注解，用状态代码和应返回的原因标记方法或异常类。调用处理程序方法时，状态代码将应用于HTTP响应。 通过上面的两个注解便可实现微服务端全局异常处理，具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package com.xuecheng.base.execption; import lombok.extern.slf4j.Slf4j; import org.springframework.http.HttpStatus; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.bind.annotation.ResponseStatus; /** * @description 全局异常处理器 * @version 1.0 */ @Slf4j @ControllerAdvice public class GlobalExceptionHandler { @ResponseBody @ExceptionHandler(XueChengPlusException.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public RestErrorResponse customException(XueChengPlusException e) { log.error(\u0026#34;【系统异常】{}\u0026#34;,e.getErrMessage(),e); return new RestErrorResponse(e.getErrMessage()); } @ResponseBody @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public RestErrorResponse exception(Exception e) { log.error(\u0026#34;【系统异常】{}\u0026#34;,e.getMessage(),e); return new RestErrorResponse(CommonError.UNKOWN_ERROR.getErrMessage()); } } 异常处理测试 在内容管理的api工程添加base工程的依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-base\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在异常处理测试之前首先在代码中抛出自定义类型的异常，这里以新增课程的service方法为例进行代码修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Override public CourseBaseInfoDto createCourseBase(Long companyId,AddCourseDto dto) { ... //合法性校验 if (StringUtils.isBlank(dto.getName())) { throw new XueChengPlusException(\u0026#34;课程名称为空\u0026#34;); } if (StringUtils.isBlank(dto.getMt())) { throw new XueChengPlusException(\u0026#34;课程分类为空\u0026#34;); } if (StringUtils.isBlank(dto.getSt())) { throw new XueChengPlusException(\u0026#34;课程分类为空\u0026#34;); } if (StringUtils.isBlank(dto.getGrade())) { throw new XueChengPlusException(\u0026#34;课程等级为空\u0026#34;); } if (StringUtils.isBlank(dto.getTeachmode())) { throw new XueChengPlusException(\u0026#34;教育模式为空\u0026#34;); } if (StringUtils.isBlank(dto.getUsers())) { throw new XueChengPlusException(\u0026#34;适应人群\u0026#34;); } if (StringUtils.isBlank(dto.getCharge())) { throw new XueChengPlusException(\u0026#34;收费规则为空\u0026#34;); } 。。。 if(charge.equals(\u0026#34;201001\u0026#34;)){ if(courseMarketNew.getPrice() ==null || courseMarketNew.getPrice().floatValue()\u0026lt;=0){ throw new XueChengPlusException(\u0026#34;课程的价格不能为空并且必须大于0\u0026#34;); } } } 。。。 首先使用httpclient测试\n请求新增课程接口，故意将必填项课程名称设置为空。\n测试结果与预期一致，可以捕获异常并响应异常信息，如下：\n1 2 3 4 5 6 7 8 9 10 11 http://localhost:63040/content/course HTTP/1.1 500 Content-Type: application/json Transfer-Encoding: chunked Date: Wed, 07 Sep 2022 13:17:14 GMT Connection: close { \u0026#34;errMessage\u0026#34;: \u0026#34;课程名称为空。\u0026#34; } 前后端调试\n仍然测试新增课程接口，当课程收费的时候必须填写价格，这里设置课程为收费，价格设置为空。\n通过测试发现，前端正常提示代码 中抛出的异常信息。\n至此，项目异常处理的测试完毕，在开发中对于业务分支中错误的情况要抛出项目自定义的异常类型。\nJSR303校验 统一校验的需求 前端请求后端接口传输参数，是在controller中校验还是在Service中校验？\n答案是都需要校验，只是分工不同。 Contoller中校验请求参数的合法性，包括：必填项校验，数据格式校验，比如：是否是符合一定的日期格式，等。\nService中要校验的是业务规则相关的内容，比如：课程已经审核通过所以提交失败。\nService中根据业务规则去校验不方便写成通用代码，Controller中则可以将校验的代码写成通用代码。\n早在JavaEE6规范中就定义了参数校验的规范，它就是JSR-303，它定义了Bean Validation，即对bean属性进行校验。\nSpringBoot提供了JSR-303的支持，它就是spring-boot-starter-validation，它的底层使用Hibernate Validator，Hibernate Validator是Bean Validation 的参考实现。\n所以，我们准备在Controller层使用spring-boot-starter-validation完成对请求参数的基本合法性进行校验。\n统一校验实现 首先在Base工程添加spring-boot-starter-validation的依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在javax.validation.constraints包下有很多这样的校验注解，直接使用注解定义校验规则即可。 注解名称 功能描述 常用属性 @NotNull 注解用于表示该字段不能为 null。 无 @NotEmpty 注解用于表示该字符串字段不能为 null 并且不能为一个空字符串。 无 @NotBlank 注解用于表示该字符串字段不能为 null、空字符串或只包含空白字符。 无 @Size 注解用于限制字符串、集合、数组或数字的大小。 min、max @Min 用于指定一个字段的值必须大于等于指定的最小值。 value @Max 用于指定一个字段的值必须小于等于指定的最大值。 value @DecimalMin 用于指定一个字段的值必须大于等于指定的小数值。 value、inclusive @DecimalMax 用于指定一个字段的值必须小于等于指定的小数值。 value、inclusive @Range 用于验证数值是否在指定范围内（需要引入额外的 Hibernate Validator）。 min、max @Email 注解用于表示该字段必须是一个有效的电子邮件地址。 regexp（可选自定义正则表达式） @Pattern 用于指定一个字段的值必须符合指定的正则表达式。 regexp、flags @Future 用于验证一个日期必须是将来的日期。 无 @Past 用于验证一个日期必须是过去的日期。 无 @Positive 用于验证一个数字必须是正数。 无 @PositiveOrZero 用于验证一个数字必须是零或正数。 无 @Negative 用于验证一个数字必须是负数。 无 @NegativeOrZero 用于验证一个数字必须是零或负数。 无 @AssertTrue 用于验证一个字段的布尔值必须为 true。 无 @AssertFalse 用于验证一个字段的布尔值必须为 false。 无 现在准备对内容管理模块添加课程接口进行参数校验，如下接口\n1 2 3 4 5 6 7 @ApiOperation(\u0026#34;新增课程基础信息\u0026#34;) @PostMapping(\u0026#34;/course\u0026#34;) public CourseBaseInfoDto createCourseBase(@RequestBody AddCourseDto addCourseDto){ //机构id，由于认证系统没有上线暂时硬编码 Long companyId = 1232141425L; return courseBaseInfoService.createCourseBase(companyId,addCourseDto); } 此接口使用AddCourseDto模型对象接收参数，所以进入AddCourseDto类，在属性上添加校验规则。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package com.xuecheng.content.model.dto; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import javax.validation.constraints.NotEmpty; import javax.validation.constraints.Size; import java.math.BigDecimal; /** * @description 添加课程dto * @version 1.0 */ @Data @ApiModel(value=\u0026#34;AddCourseDto\u0026#34;, description=\u0026#34;新增课程基本信息\u0026#34;) public class AddCourseDto { @NotEmpty(message = \u0026#34;课程名称不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;课程名称\u0026#34;, required = true) private String name; @NotEmpty(message = \u0026#34;适用人群不能为空\u0026#34;) @Size(message = \u0026#34;适用人群内容过少\u0026#34;,min = 10) @ApiModelProperty(value = \u0026#34;适用人群\u0026#34;, required = true) private String users; @ApiModelProperty(value = \u0026#34;课程标签\u0026#34;) private String tags; @NotEmpty(message = \u0026#34;课程分类不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;大分类\u0026#34;, required = true) private String mt; @NotEmpty(message = \u0026#34;课程分类不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;小分类\u0026#34;, required = true) private String st; @NotEmpty(message = \u0026#34;课程等级不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;课程等级\u0026#34;, required = true) private String grade; @ApiModelProperty(value = \u0026#34;教学模式（普通，录播，直播等）\u0026#34;, required = true) private String teachmode; @ApiModelProperty(value = \u0026#34;课程介绍\u0026#34;) private String description; @ApiModelProperty(value = \u0026#34;课程图片\u0026#34;, required = true) private String pic; @NotEmpty(message = \u0026#34;收费规则不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;收费规则，对应数据字典\u0026#34;, required = true) private String charge; @ApiModelProperty(value = \u0026#34;价格\u0026#34;) private BigDecimal price; } 上边用到了@NotEmpty和@Size两个注解，@NotEmpty表示属性不能为空，@Size表示限制属性内容的长短。\n定义好校验规则还需要开启校验，在controller方法中添加@Validated注解，如下：\n1 2 3 4 5 6 7 @ApiOperation(\u0026#34;新增课程基础信息\u0026#34;) @PostMapping(\u0026#34;/course\u0026#34;) public CourseBaseInfoDto createCourseBase(@RequestBody @Validated AddCourseDto addCourseDto){ //机构id，由于认证系统没有上线暂时硬编码 Long companyId = 1L; return courseBaseInfoService.createCourseBase(companyId,addCourseDto); } 如果校验出错Spring会抛出MethodArgumentNotValidException异常，我们需要在统一异常处理器中捕获异常，解析出异常信息。代码 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @ResponseBody @ExceptionHandler(MethodArgumentNotValidException.class) @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) public RestErrorResponse methodArgumentNotValidException(MethodArgumentNotValidException e) { BindingResult bindingResult = e.getBindingResult(); List\u0026lt;String\u0026gt; msgList = new ArrayList\u0026lt;\u0026gt;(); //将错误信息放在msgList bindingResult.getFieldErrors().stream().forEach(item-\u0026gt;msgList.add(item.getDefaultMessage())); //拼接错误信息 String msg = StringUtils.join(msgList, \u0026#34;,\u0026#34;); log.error(\u0026#34;【系统异常】{}\u0026#34;,msg); return new RestErrorResponse(msg); } 重启内容管理服务。\n使用httpclient进行测试，将必填项设置为空，“适用人群” 属性的内容设置1个字。\n执行测试，接口响应结果如下：\n1 2 3 { \u0026#34;errMessage\u0026#34;: \u0026#34;课程名称不能为空,课程分类不能为空,课程分类不能为空,适用人群内容过少\u0026#34; } 分组校验 有时候在同一个属性上设置一个校验规则不能满足要求，比如：订单编号由系统生成，在添加订单时要求订单编号为空，在更新订单时要求订单编写不能为空。此时就用到了分组校验，同一个属性定义多个校验规则属于不同的分组，比如：添加订单定义@NULL规则属于insert分组，更新订单定义@NotEmpty规则属于update分组，insert和update是分组的名称，是可以修改的。\n下边举例说明\n我们用class类型来表示不同的分组，所以我们定义不同的接口类型（空接口）表示不同的分组，由于校验分组是公用的，所以定义在 base工程中。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 package com.xuecheng.base.execption; /** * @description 校验分组 * @version 1.0 */ public class ValidationGroups { public interface Inster{}; public interface Update{}; public interface Delete{}; } 下边在定义校验规则时指定分组：\n1 2 3 4 5 @NotEmpty(groups = {ValidationGroups.Inster.class},message = \u0026#34;添加课程名称不能为空\u0026#34;) @NotEmpty(groups = {ValidationGroups.Update.class},message = \u0026#34;修改课程名称不能为空\u0026#34;) // @NotEmpty(message = \u0026#34;课程名称不能为空\u0026#34;) @ApiModelProperty(value = \u0026#34;课程名称\u0026#34;, required = true) private String name; 在Controller方法中启动校验规则指定要使用的分组名：\n1 2 3 4 5 6 7 @ApiOperation(\u0026#34;新增课程基础信息\u0026#34;) @PostMapping(\u0026#34;/course\u0026#34;) public CourseBaseInfoDto createCourseBase(@RequestBody @Validated({ValidationGroups.Inster.class}) AddCourseDto addCourseDto){ //机构id，由于认证系统没有上线暂时硬编码 Long companyId = 1L; return courseBaseInfoService.createCourseBase(companyId,addCourseDto); } 再次测试，由于这里指定了Insert分组，所以抛出 异常信息：添加课程名称不能为空。\n如果修改分组为ValidationGroups.Update.class，异常信息为：修改课程名称不能为空。\n校验规则不满足？ 如果javax.validation.constraints包下的校验规则满足不了需求怎么办？ 手写校验代码 。 自定义校验规则注解。 修改课程 需求分析 业务流程 进入课程列表查询 点击编辑 因为课程审核通过方可发布，任何时候都可以编辑。 进入编辑界面显示出当前课程的信息。 修改成功自动进入课程计划编辑页面。 数据模型 修改课程涉及到的数据表是课程基本信息表和课程营销表\n课程基本信息表 课程营销表 进入课程编辑界面\n界面中显示了课程的当前信息，需要根据课程id查询课程基本和课程营销信息，显示在表单上。 编辑、提交\n修改课程提交的数据比新增课程多了一项课程id，因为修改课程需要针对某个课程进行修改。 保存数据\n编辑完成保存课程基础信息和课程营销信息。 更新课程基本信息表中的修改人、修改时间。 接口定义 查询课程学习 定义根据课程id查询课程信息接口，接口示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 GET /content/course/40 Content-Type: application/json #响应结果 #{ # \u0026#34;id\u0026#34;: 40, # \u0026#34;companyId\u0026#34;: 1232141425, # \u0026#34;companyName\u0026#34;: null, # \u0026#34;name\u0026#34;: \u0026#34;SpringBoot核心\u0026#34;, # \u0026#34;users\u0026#34;: \u0026#34;Spring Boot初学者\u0026#34;, # \u0026#34;tags\u0026#34;: \u0026#34;Spring项目的快速构建\u0026#34;, # \u0026#34;mt\u0026#34;: \u0026#34;1-3\u0026#34;, # \u0026#34;mtName\u0026#34;: null, # \u0026#34;st\u0026#34;: \u0026#34;1-3-2\u0026#34;, # \u0026#34;stName\u0026#34;: null, # \u0026#34;grade\u0026#34;: \u0026#34;200003\u0026#34;, # \u0026#34;teachmode\u0026#34;: \u0026#34;201001\u0026#34;, # \u0026#34;description\u0026#34;: \u0026#34;课程系统性地深度探讨 Spring Boot 核心特性，引导小伙伴对 Java 规范的重视，启发对技术原理性的思考，掌握排查问题的技能，以及学习阅读源码的方法和技巧，全面提升研发能力，进军架构师队伍。\u0026#34;, # \u0026#34;pic\u0026#34;: \u0026#34;https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg\u0026#34;, # \u0026#34;createDate\u0026#34;: \u0026#34;2019-09-10 16:05:39\u0026#34;, # \u0026#34;changeDate\u0026#34;: \u0026#34;2022-09-09 07:27:48\u0026#34;, # \u0026#34;createPeople\u0026#34;: null, # \u0026#34;changePeople\u0026#34;: null, # \u0026#34;auditStatus\u0026#34;: \u0026#34;202004\u0026#34;, # \u0026#34;status\u0026#34;: \u0026#34;203001\u0026#34;, # \u0026#34;coursePubId\u0026#34;: 21, # \u0026#34;coursePubDate\u0026#34;: null, # \u0026#34;charge\u0026#34;: \u0026#34;201001\u0026#34;, # \u0026#34;price\u0026#34;: 0.01 #} 查询结果为单条课程信息，内容和新增课程返回结果一致，所以采用与新增课程一致的模型类，接口定义如下：\n1 2 3 4 5 @ApiOperation(\u0026#34;根据课程id查询课程基础信息\u0026#34;) @GetMapping(\u0026#34;/course/{courseId}\u0026#34;) public CourseBaseInfoDto getCourseBaseById(@PathVariable Long courseId){ return null; } 修改课程信息 根据前边的数据模型分析，修改课程提交的数据比新增多了课程id，接口示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 ### 修改课程 PUT /content/course Content-Type: application/json ###请求参数 { \u0026#34;id\u0026#34;: 40, \u0026#34;companyName\u0026#34;: null, \u0026#34;name\u0026#34;: \u0026#34;SpringBoot核心\u0026#34;, \u0026#34;users\u0026#34;: \u0026#34;Spring Boot初学者\u0026#34;, \u0026#34;tags\u0026#34;: \u0026#34;Spring项目的快速构建\u0026#34;, \u0026#34;mt\u0026#34;: \u0026#34;1-3\u0026#34;, \u0026#34;st\u0026#34;: \u0026#34;1-3-2\u0026#34;, \u0026#34;grade\u0026#34;: \u0026#34;200003\u0026#34;, \u0026#34;teachmode\u0026#34;: \u0026#34;201001\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;课程系统性地深度探讨 Spring Boot 核心特性，引导小伙伴对 Java 规范的重视，启发对技术原理性的思考，掌握排查问题的技能，以及学习阅读源码的方法和技巧，全面提升研发能力，进军架构师队伍。\u0026#34;, \u0026#34;pic\u0026#34;: \u0026#34;https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg\u0026#34;, \u0026#34;charge\u0026#34;: \u0026#34;201001\u0026#34;, \u0026#34;price\u0026#34;: 0.01 } ###修改成功响应结果如下 #{ # \u0026#34;id\u0026#34;: 40, # \u0026#34;companyId\u0026#34;: 1232141425, # \u0026#34;companyName\u0026#34;: null, # \u0026#34;name\u0026#34;: \u0026#34;SpringBoot核心\u0026#34;, # \u0026#34;users\u0026#34;: \u0026#34;Spring Boot初学者\u0026#34;, # \u0026#34;tags\u0026#34;: \u0026#34;Spring项目的快速构建\u0026#34;, # \u0026#34;mt\u0026#34;: \u0026#34;1-3\u0026#34;, # \u0026#34;mtName\u0026#34;: null, # \u0026#34;st\u0026#34;: \u0026#34;1-3-2\u0026#34;, # \u0026#34;stName\u0026#34;: null, # \u0026#34;grade\u0026#34;: \u0026#34;200003\u0026#34;, # \u0026#34;teachmode\u0026#34;: \u0026#34;201001\u0026#34;, # \u0026#34;description\u0026#34;: \u0026#34;课程系统性地深度探讨 Spring Boot 核心特性，引导小伙伴对 Java 规范的重视，启发对技术原理性的思考，掌握排查问题的技能，以及学习阅读源码的方法和技巧，全面提升研发能力，进军架构师队伍。\u0026#34;, # \u0026#34;pic\u0026#34;: \u0026#34;https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg\u0026#34;, # \u0026#34;createDate\u0026#34;: \u0026#34;2019-09-10 16:05:39\u0026#34;, # \u0026#34;changeDate\u0026#34;: \u0026#34;2022-09-09 07:27:48\u0026#34;, # \u0026#34;createPeople\u0026#34;: null, # \u0026#34;changePeople\u0026#34;: null, # \u0026#34;auditStatus\u0026#34;: \u0026#34;202004\u0026#34;, # \u0026#34;status\u0026#34;: \u0026#34;203001\u0026#34;, # \u0026#34;coursePubId\u0026#34;: 21, # \u0026#34;coursePubDate\u0026#34;: null, # \u0026#34;charge\u0026#34;: \u0026#34;201001\u0026#34;, # \u0026#34;price\u0026#34;: 0.01 #} 这里定义修改课程提交的请求参数模型(相较于新增课程信息的接口的请求参数模型多了一个id)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package com.xuecheng.content.model.dto; import com.xuecheng.base.execption.ValidationGroups; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import javax.validation.constraints.NotEmpty; import javax.validation.constraints.NotNull; import javax.validation.constraints.Size; import java.math.BigDecimal; /** * @description 添加课程dto * @version 1.0 */ @Data @ApiModel(value=\u0026#34;EditCourseDto\u0026#34;, description=\u0026#34;修改课程基本信息\u0026#34;) public class EditCourseDto extends AddCourseDto { @ApiModelProperty(value = \u0026#34;课程id\u0026#34;, required = true) private Long id; } 修改后返回最新课程信息，采用与新增课程接口返回类型一致的数据模型。接口定义如下：\n1 2 3 4 5 @ApiOperation(\u0026#34;修改课程基础信息\u0026#34;) @PutMapping(\u0026#34;/course\u0026#34;) public CourseBaseInfoDto modifyCourseBase(@RequestBody @Validated EditCourseDto editCourseDto){ return null; } 接口开发 查询课程信息 查询课程信息的Service方法在新增课程接口开发中已实现，无需实现，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //根据课程id查询课程基本信息，包括基本信息和营销信息 public CourseBaseInfoDto getCourseBaseInfo(long courseId){ //查询课程信息 CourseBase courseBase = courseBaseMapper.selectById(courseId); if(courseBase == null){ return null; } //查询营销信息 CourseMarket courseMarket = courseMarketMapper.selectById(courseId); //要返回的对象 CourseBaseInfoDto courseBaseInfoDto = new CourseBaseInfoDto(); BeanUtils.copyProperties(courseBase,courseBaseInfoDto); if(courseMarket != null){ BeanUtils.copyProperties(courseMarket,courseBaseInfoDto); } //查询分类名称 CourseCategory courseCategoryBySt = courseCategoryMapper.selectById(courseBase.getSt()); courseBaseInfoDto.setStName(courseCategoryBySt.getName()); CourseCategory courseCategoryByMt = courseCategoryMapper.selectById(courseBase.getMt()); courseBaseInfoDto.setMtName(courseCategoryByMt.getName()); return courseBaseInfoDto; } 需要将查询课程信息的方法提到接口上，这样在controller中通过接口调用此方法。\n1 2 3 4 5 6 7 8 9 public interface CourseBaseInfoService { .... /** * @description 根据id查询课程基本信息 * @param courseId 课程id * @return */ public CourseBaseInfoDto getCourseBaseInfo(long courseId); ... 完善接口层代码 ：\n1 2 3 4 5 @ApiOperation(\u0026#34;根据课程id查询课程基础信息\u0026#34;) @GetMapping(\u0026#34;/course/{courseId}\u0026#34;) public CourseBaseInfoDto getCourseBaseById(@PathVariable Long courseId){ return courseBaseInfoService.getCourseBaseInfo(courseId); } 测试查询课程，用httpclient测试查询课程接口：\n1 2 ### 查询课程信息 GET /content/course/40 修改课程信息 修改Service修改课程的接口与方法：\n1 2 3 4 5 6 7 /** * @description 修改课程信息 * @param companyId 机构id * @param dto 课程信息 * @return com.xuecheng.content.model.dto.CourseBaseInfoDto */ public CourseBaseInfoDto updateCourseBase(Long companyId,EditCourseDto dto); 实现方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Transactional @Override public CourseBaseInfoDto updateCourseBase(Long companyId, EditCourseDto dto) { //课程id Long courseId = dto.getId(); CourseBase courseBase = courseBaseMapper.selectById(courseId); if(courseBase==null){ XueChengPlusException.cast(\u0026#34;课程不存在\u0026#34;); } //校验本机构只能修改本机构的课程 if(!courseBase.getCompanyId().equals(companyId)){ XueChengPlusException.cast(\u0026#34;本机构只能修改本机构的课程\u0026#34;); } //封装基本信息的数据 BeanUtils.copyProperties(dto,courseBase); courseBase.setChangeDate(LocalDateTime.now()); //更新课程基本信息 int i = courseBaseMapper.updateById(courseBase); //封装营销信息的数据 CourseMarket courseMarket = new CourseMarket(); BeanUtils.copyProperties(dto,courseMarket); saveCourseMarket(courseMarket); //查询课程信息 CourseBaseInfoDto courseBaseInfo = this.getCourseBaseInfo(courseId); return courseBaseInfo; } 最后完善接口层代码：\n1 2 3 4 5 6 7 @ApiOperation(\u0026#34;修改课程基础信息\u0026#34;) @PutMapping(\u0026#34;/course\u0026#34;) public CourseBaseInfoDto modifyCourseBase(@RequestBody @Validated EditCourseDto editCourseDto){ //机构id，由于认证系统没有上线暂时硬编码 Long companyId = 1232141425L; return courseBaseInfoService.updateCourseBase(companyId,editCourseDto); } 接口测试 接口开发完成进行测试，使用httpclient测试\n测试查询课程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ### 根据课程id查询课程信息 GET {{content_host}}/content/course/40 Content-Type: application/json #响应结果 #{ # \u0026#34;id\u0026#34;: 40, # \u0026#34;companyId\u0026#34;: 1232141425, # \u0026#34;companyName\u0026#34;: null, # \u0026#34;name\u0026#34;: \u0026#34;SpringBoot核心\u0026#34;, # \u0026#34;users\u0026#34;: \u0026#34;Spring Boot初学者\u0026#34;, # \u0026#34;tags\u0026#34;: \u0026#34;Spring项目的快速构建\u0026#34;, # \u0026#34;mt\u0026#34;: \u0026#34;1-3\u0026#34;, # \u0026#34;mtName\u0026#34;: null, # \u0026#34;st\u0026#34;: \u0026#34;1-3-2\u0026#34;, # \u0026#34;stName\u0026#34;: null, # \u0026#34;grade\u0026#34;: \u0026#34;200003\u0026#34;, # \u0026#34;teachmode\u0026#34;: \u0026#34;201001\u0026#34;, # \u0026#34;description\u0026#34;: \u0026#34;课程系统性地深度探讨 Spring Boot 核心特性，引导小伙伴对 Java 规范的重视，启发对技术原理性的思考，掌握排查问题的技能，以及学习阅读源码的方法和技巧，全面提升研发能力，进军架构师队伍。\u0026#34;, # \u0026#34;pic\u0026#34;: \u0026#34;https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg\u0026#34;, # \u0026#34;createDate\u0026#34;: \u0026#34;2019-09-10 16:05:39\u0026#34;, # \u0026#34;changeDate\u0026#34;: \u0026#34;2022-09-09 07:27:48\u0026#34;, # \u0026#34;createPeople\u0026#34;: null, # \u0026#34;changePeople\u0026#34;: null, # \u0026#34;auditStatus\u0026#34;: \u0026#34;202004\u0026#34;, # \u0026#34;status\u0026#34;: \u0026#34;203001\u0026#34;, # \u0026#34;coursePubId\u0026#34;: 21, # \u0026#34;coursePubDate\u0026#34;: null, # \u0026#34;charge\u0026#34;: \u0026#34;201001\u0026#34;, # \u0026#34;price\u0026#34;: 0.01 #} 测试修改课程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ### 修改课程 PUT {{content_host}}/content/course Content-Type: application/json { \u0026#34;id\u0026#34;: 40, \u0026#34;name\u0026#34;: \u0026#34;SpringBoot核心\u0026#34;, \u0026#34;users\u0026#34;: \u0026#34;Spring Boot初学者\u0026#34;, \u0026#34;tags\u0026#34;: \u0026#34;Spring项目的快速构建\u0026#34;, \u0026#34;mt\u0026#34;: \u0026#34;1-3\u0026#34;, \u0026#34;st\u0026#34;: \u0026#34;1-3-2\u0026#34;, \u0026#34;grade\u0026#34;: \u0026#34;200003\u0026#34;, \u0026#34;teachmode\u0026#34;: \u0026#34;201001\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;课程系统性地深度探讨 Spring Boot 核心特性，引导小伙伴对 Java 规范的重视，启发对技术原理性的思考，掌握排查问题的技能，以及学习阅读源码的方法和技巧，全面提升研发能力，进军架构师队伍。\u0026#34;, \u0026#34;pic\u0026#34;: \u0026#34;https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg\u0026#34;, \u0026#34;charge\u0026#34;: \u0026#34;201001\u0026#34;, \u0026#34;price\u0026#34;: 0.01 } ###修改成功响应结果如下 #{ # \u0026#34;id\u0026#34;: 40, # \u0026#34;companyId\u0026#34;: 1232141425, # \u0026#34;companyName\u0026#34;: null, # \u0026#34;name\u0026#34;: \u0026#34;SpringBoot核心\u0026#34;, # \u0026#34;users\u0026#34;: \u0026#34;Spring Boot初学者\u0026#34;, # \u0026#34;tags\u0026#34;: \u0026#34;Spring项目的快速构建\u0026#34;, # \u0026#34;mt\u0026#34;: \u0026#34;1-3\u0026#34;, # \u0026#34;mtName\u0026#34;: null, # \u0026#34;st\u0026#34;: \u0026#34;1-3-2\u0026#34;, # \u0026#34;stName\u0026#34;: null, # \u0026#34;grade\u0026#34;: \u0026#34;200003\u0026#34;, # \u0026#34;teachmode\u0026#34;: \u0026#34;201001\u0026#34;, # \u0026#34;description\u0026#34;: \u0026#34;课程系统性地深度探讨 Spring Boot 核心特性，引导小伙伴对 Java 规范的重视，启发对技术原理性的思考，掌握排查问题的技能，以及学习阅读源码的方法和技巧，全面提升研发能力，进军架构师队伍。\u0026#34;, # \u0026#34;pic\u0026#34;: \u0026#34;https://cdn.educba.com/academy/wp-content/uploads/2018/08/Spring-BOOT-Interview-questions.jpg\u0026#34;, # \u0026#34;createDate\u0026#34;: \u0026#34;2019-09-10 16:05:39\u0026#34;, # \u0026#34;changeDate\u0026#34;: \u0026#34;2022-09-09 07:27:48\u0026#34;, # \u0026#34;createPeople\u0026#34;: null, # \u0026#34;changePeople\u0026#34;: null, # \u0026#34;auditStatus\u0026#34;: \u0026#34;202004\u0026#34;, # \u0026#34;status\u0026#34;: \u0026#34;203001\u0026#34;, # \u0026#34;coursePubId\u0026#34;: 21, # \u0026#34;coursePubDate\u0026#34;: null, # \u0026#34;charge\u0026#34;: \u0026#34;201001\u0026#34;, # \u0026#34;price\u0026#34;: 0.01 #} 查询课程计划 需求分析 业务流程 课程基本信息添加或修改成功将自动进入课程计划编辑器界面 课程计划即课程的大纲目录。 课程计划分为两级：大章节和不小章节。 本小节完成课程计划信息的查询。 数据模型 从课程计划查询界面上可以看出整体上是 一个树型结构，课程计划表teachplan如下：\n每个课程计划都有所属课程。 每个课程的课程计划有两个级别，第一级为大章节，grade为1、第二级为小章节，grade为2 第二级的parentid为第一级的id。 课程计划的显示顺序根据排序字段去显示。 根据业务流程中的界面原型，课程计划列表展示时还有课程计划关联的视频信息。课程计划关联的视频信息在teachplan_media表，结构如下：\n两张表是一对一关系，每个课程计划只能在teachplan_media表中存在一个视频。 接口定义 接口示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 GET /teachplan/22/tree-nodes [ { \u0026#34;changeDate\u0026#34; : null, \u0026#34;courseId\u0026#34; : 74, \u0026#34;cousePubId\u0026#34; : null, \u0026#34;createDate\u0026#34; : null, \u0026#34;endTime\u0026#34; : null, \u0026#34;grade\u0026#34; : \u0026#34;2\u0026#34;, \u0026#34;isPreview\u0026#34; : \u0026#34;0\u0026#34;, \u0026#34;mediaType\u0026#34; : null, \u0026#34;orderby\u0026#34; : 1, \u0026#34;parentid\u0026#34; : 112, \u0026#34;pname\u0026#34; : \u0026#34;第1章基础知识\u0026#34;, \u0026#34;startTime\u0026#34; : null, \u0026#34;status\u0026#34; : null, \u0026#34;id\u0026#34; : 113, \u0026#34;teachPlanTreeNodes\u0026#34; : [ { \u0026#34;changeDate\u0026#34; : null, \u0026#34;courseId\u0026#34; : 74, \u0026#34;cousePubId\u0026#34; : null, \u0026#34;createDate\u0026#34; : null, \u0026#34;endTime\u0026#34; : null, \u0026#34;grade\u0026#34; : \u0026#34;3\u0026#34;, \u0026#34;isPreview\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;mediaType\u0026#34; : \u0026#34;001002\u0026#34;, \u0026#34;orderby\u0026#34; : 1, \u0026#34;parentid\u0026#34; : 113, \u0026#34;pname\u0026#34; : \u0026#34;第1节项目概述\u0026#34;, \u0026#34;startTime\u0026#34; : null, \u0026#34;status\u0026#34; : null, \u0026#34;id\u0026#34; : 115, \u0026#34;teachPlanTreeNodes\u0026#34; : null, \u0026#34;teachplanMedia\u0026#34; : { \u0026#34;courseId\u0026#34; : 74, \u0026#34;coursePubId\u0026#34; : null, \u0026#34;mediaFilename\u0026#34; : \u0026#34;2.avi\u0026#34;, \u0026#34;mediaId\u0026#34; : 41, \u0026#34;teachplanId\u0026#34; : 115, \u0026#34;id\u0026#34; : null } } ], \u0026#34;teachplanMedia\u0026#34; : null }, { \u0026#34;changeDate\u0026#34; : null, \u0026#34;courseId\u0026#34; : 74, \u0026#34;cousePubId\u0026#34; : null, \u0026#34;createDate\u0026#34; : null, \u0026#34;endTime\u0026#34; : null, \u0026#34;grade\u0026#34; : \u0026#34;2\u0026#34;, \u0026#34;isPreview\u0026#34; : \u0026#34;0\u0026#34;, \u0026#34;mediaType\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;orderby\u0026#34; : 1, \u0026#34;parentid\u0026#34; : 112, \u0026#34;pname\u0026#34; : \u0026#34;第2章快速入门\u0026#34;, \u0026#34;startTime\u0026#34; : null, \u0026#34;status\u0026#34; : null, \u0026#34;id\u0026#34; : 242, \u0026#34;teachPlanTreeNodes\u0026#34; : [ { \u0026#34;changeDate\u0026#34; : null, \u0026#34;courseId\u0026#34; : 74, \u0026#34;cousePubId\u0026#34; : null, \u0026#34;createDate\u0026#34; : null, \u0026#34;endTime\u0026#34; : null, \u0026#34;grade\u0026#34; : \u0026#34;3\u0026#34;, \u0026#34;isPreview\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;mediaType\u0026#34; : \u0026#34;001002\u0026#34;, \u0026#34;orderby\u0026#34; : 2, \u0026#34;parentid\u0026#34; : 242, \u0026#34;pname\u0026#34; : \u0026#34;第1节搭建环境\u0026#34;, \u0026#34;startTime\u0026#34; : null, \u0026#34;status\u0026#34; : null, \u0026#34;id\u0026#34; : 244, \u0026#34;teachPlanTreeNodes\u0026#34; : null, \u0026#34;teachplanMedia\u0026#34; : { \u0026#34;courseId\u0026#34; : 74, \u0026#34;coursePubId\u0026#34; : null, \u0026#34;mediaFilename\u0026#34; : \u0026#34;3.avi\u0026#34;, \u0026#34;mediaId\u0026#34; : 42, \u0026#34;teachplanId\u0026#34; : 244, \u0026#34;id\u0026#34; : null } }, { \u0026#34;changeDate\u0026#34; : null, \u0026#34;courseId\u0026#34; : 74, \u0026#34;cousePubId\u0026#34; : null, \u0026#34;createDate\u0026#34; : null, \u0026#34;endTime\u0026#34; : null, \u0026#34;grade\u0026#34; : \u0026#34;3\u0026#34;, \u0026#34;isPreview\u0026#34; : \u0026#34;0\u0026#34;, \u0026#34;mediaType\u0026#34; : \u0026#34;001002\u0026#34;, \u0026#34;orderby\u0026#34; : 3, \u0026#34;parentid\u0026#34; : 242, \u0026#34;pname\u0026#34; : \u0026#34;第2节项目概述\u0026#34;, \u0026#34;startTime\u0026#34; : null, \u0026#34;status\u0026#34; : null, \u0026#34;id\u0026#34; : 245, \u0026#34;teachPlanTreeNodes\u0026#34; : null, \u0026#34;teachplanMedia\u0026#34; : { \u0026#34;courseId\u0026#34; : 74, \u0026#34;coursePubId\u0026#34; : null, \u0026#34;mediaFilename\u0026#34; : \u0026#34;1a.avi\u0026#34;, \u0026#34;mediaId\u0026#34; : 39, \u0026#34;teachplanId\u0026#34; : 245, \u0026#34;id\u0026#34; : null } } ], \u0026#34;teachplanMedia\u0026#34; : null } ] 查询课程计划的请求参数：课程id\n响应结果需要自定义模型类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.xuecheng.content.model.dto; import com.xuecheng.content.model.po.Teachplan; import com.xuecheng.content.model.po.TeachplanMedia; import lombok.Data; import lombok.ToString; import java.util.List; /** * @description 课程计划树型结构dto * @version 1.0 */ @Data @ToString public class TeachplanDto extends Teachplan { //课程计划关联的媒资信息 TeachplanMedia teachplanMedia; //子结点 List\u0026lt;TeachplanDto\u0026gt; teachPlanTreeNodes; } 定义接口如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.xuecheng.content.api; import com.xuecheng.content.model.dto.TeachplanDto; import io.swagger.annotations.Api; import io.swagger.annotations.ApiImplicitParam; import io.swagger.annotations.ApiOperation; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; /** * @description 课程计划编辑接口 * @author Mr.M * @date 2022/9/6 11:29 * @version 1.0 */ @Api(value = \u0026#34;课程计划编辑接口\u0026#34;,tags = \u0026#34;课程计划编辑接口\u0026#34;) @RestController public class TeachplanController { @ApiOperation(\u0026#34;查询课程计划树形结构\u0026#34;) @ApiImplicitParam(value = \u0026#34;courseId\u0026#34;,name = \u0026#34;课程Id\u0026#34;,required = true,dataType = \u0026#34;Long\u0026#34;,paramType = \u0026#34;path\u0026#34;) @GetMapping(\u0026#34;/teachplan/{courseId}/tree-nodes\u0026#34;) public List\u0026lt;TeachplanDto\u0026gt; getTreeNodes(@PathVariable Long courseId){ return null; } } 接口开发 DAO开发 Mapper接口使用sql查询课程计划，组成一个树型结构。\n在TeachplanMapper自定义方法：\n1 2 3 4 5 6 7 8 9 10 public interface TeachplanMapper extends BaseMapper\u0026lt;Teachplan\u0026gt; { /** * @description 查询某课程的课程计划，组成树型结构 * @param courseId * @return com.xuecheng.content.model.dto.TeachplanDto */ public List\u0026lt;TeachplanDto\u0026gt; selectTreeNodes(long courseId); } 定义mapper.xml中的sql语句，分析如下：\n一级分类和二级分类通过teachplan表的自链接进行，如果只有一级分类其下边没有二级分类，此时也需要显示一级分类，这里使用左连接，左边是一级分类，右边是二级分类。\n由于当还没有关联 视频时teachplan_media对应的记录为空，所以需要teachplan和teachplan_media左链接。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;select id=\u0026#34;selectTreeNodes\u0026#34; resultMap=\u0026#34;treeNodeResultMap\u0026#34; parameterType=\u0026#34;long\u0026#34; \u0026gt; select one.id one_id, one.pname one_pname, one.parentid one_parentid, one.grade one_grade, one.media_type one_mediaType, one.start_time one_stratTime, one.end_time one_endTime, one.orderby one_orderby, one.course_id one_courseId, one.course_pub_id one_coursePubId, two.id two_id, two.pname two_pname, two.parentid two_parentid, two.grade two_grade, two.media_type two_mediaType, two.start_time two_stratTime, two.end_time two_endTime, two.orderby two_orderby, two.course_id two_courseId, two.course_pub_id two_coursePubId, m1.media_fileName mediaFilename, m1.id teachplanMeidaId, m1.media_id mediaId FROM teachplan one INNER JOIN teachplan two ON one.id = two.parentid LEFT JOIN teachplan_media m1 ON m1.teachplan_id = two.id WHERE one.parentid = 0 AND one.course_id = # { VALUE } ORDER BY one.orderby, two.orderby \u0026lt;/select\u0026gt; Service开发 定义service接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.xuecheng.content.service; import com.xuecheng.base.model.PageParams; import com.xuecheng.base.model.PageResult; import com.xuecheng.content.model.dto.*; import com.xuecheng.content.model.po.CourseBase; /** * @description 课程基本信息管理业务接口 */ public interface TeachplanService { /** * @description 查询课程计划树型结构 * @param courseId 课程id * @return List\u0026lt;TeachplanDto\u0026gt; */ public List\u0026lt;TeachplanDto\u0026gt; findTeachplanTree(long courseId); } 定义service接口实现类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.xuecheng.content.service.impl; import com.xuecheng.content.mapper.TeachplanMapper; import com.xuecheng.content.model.dto.TeachplanDto; import com.xuecheng.content.service.TeachplanService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; /** * @description 课程计划service接口实现类 * @author Mr.M */ @Service public class TeachplanServiceImpl implements TeachplanService { @Autowired TeachplanMapper teachplanMapper; @Override public List\u0026lt;TeachplanDto\u0026gt; findTeachplanTree(long courseId) { return teachplanMapper.selectTreeNodes(courseId); } } 接口测试 完善接口层代码\n1 2 3 4 5 6 7 8 9 @Autowired TeachplanService teachplanService; @ApiOperation(\u0026#34;查询课程计划树形结构\u0026#34;) @ApiImplicitParam(value = \u0026#34;courseId\u0026#34;,name = \u0026#34;课程基础Id值\u0026#34;,required = true,dataType = \u0026#34;Long\u0026#34;,paramType = \u0026#34;path\u0026#34;) @GetMapping(\u0026#34;teachplan/{courseId}/tree-nodes\u0026#34;) public List\u0026lt;TeachplanDto\u0026gt; getTreeNodes(@PathVariable Long courseId){ return teachplanService.findTeachplanTree(courseId); } 使用httpclient测试，找一个有课程计划的课程进行测试\n1 2 3 ### 查询某个课程的课程计划 GET {{content_host}}/content/teachplan/74/tree-nodes 前后端联调\n进入课程编辑页面保存进入下一步 观察课程计划获取是否成功。 新增/修改课程计划 需求分析 业务流程 进入课程计划界面 点击“添加章”新增第一级课程计划。 新增成功自动刷新课程计划列表。 新增的课程计划自动排序到最后。 点击“添加小节”向某个第一级课程计划下添加小节。 新增成功自动刷新课程计划列表。 新增的课程计划自动排序到最后。 点击“章”、“节”的名称，可以修改名称、选择是否免费。 数据模型 涉及到的数据表教学计划表以及教学计划和媒资的关系表 新增第一级课程计划 名称默认为：新章名称 [点击修改] grade：1 orderby: 所属课程中同级别下排在最后 新增第二级课程计划 名称默认为：新小节名称 [点击修改] grade：2 orderby: 所属课程计划中排在最后 修改第一级、第二级课程计划的名称，修改第二级课程计划是否免费 接口定义 接口示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ### 新增课程计划--章,当grade为1时parentid为0 POST /teachplan Content-Type: application/json ###请求参数 { \u0026#34;courseId\u0026#34; : 74, \u0026#34;parentid\u0026#34;: 0, \u0026#34;grade\u0026#34; : 1, \u0026#34;pname\u0026#34; : \u0026#34;新章名称 [点击修改]\u0026#34; } ### 新增课程计划--节 POST {{content_host}}/content/teachplan Content-Type: application/json { \u0026#34;courseId\u0026#34; : 74, \u0026#34;parentid\u0026#34;: 247, \u0026#34;grade\u0026#34; : 2, \u0026#34;pname\u0026#34; : \u0026#34;小节名称 [点击修改]\u0026#34; } 同一个接口接收新增和修改两个业务请求，以是否传递课程计划id 来判断是新增还是修改。\n如果传递了课程计划id说明当前是要修改该课程计划，否则是新增一个课程计划。 定义接收请求参数的数据模型类：SaveTeachplanDto\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package com.xuecheng.content.model.dto; import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.TableField; import com.xuecheng.content.model.po.Teachplan; import com.xuecheng.content.model.po.TeachplanMedia; import lombok.Data; import lombok.ToString; import java.time.LocalDateTime; import java.util.List; /** * @description 保存课程计划dto，包括新增、修改 * @version 1.0 */ @Data @ToString public class SaveTeachplanDto { /*** * 教学计划id */ private Long id; /** * 课程计划名称 */ private String pname; /** * 课程计划父级Id */ private Long parentid; /** * 层级，分为1、2、3级 */ private Integer grade; /** * 课程类型:1视频、2文档 */ private String mediaType; /** * 课程标识 */ private Long courseId; /** * 课程发布标识 */ private Long coursePubId; /** * 是否支持试学或预览（试看） */ private String isPreview; } 定义接口如下：\n1 2 3 4 5 @ApiOperation(\u0026#34;课程计划创建或修改\u0026#34;) @PostMapping(\u0026#34;/teachplan\u0026#34;) public void saveTeachplan( @RequestBody SaveTeachplanDto teachplan){ return null; } 接口开发\nMapper开发 根据业务的分析，Mapper使用自动生成的mapper即可满足要求。 Service开发 定义保存课程计划的Service接口。\n1 2 3 4 5 6 /** * @description 只在课程计划 * @param teachplanDto 课程计划信息 * @return void */ public void saveTeachplan(SaveTeachplanDto teachplanDto); 编写接口实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @Override public void saveTeachplan(SaveTeachplanDto saveTeachplanDto) { //1. 数据的逻辑判断 //此处判断其courseId对应的课程是否存在 //1.1 根据courseId查找course CourseBase courseBase = courseBaseMapper.selectById(saveTeachplanDto.getCourseId()); //1.2 判断是否存在 if(courseBase==null){ //1.3 不存在，直接异常 XueChengPlusException.cast(\u0026#34;当前章节无对应的课程\u0026#34;); } //2.判断是更新还是插入 //2.1 取出章节的id Long id = saveTeachplanDto.getId(); //2.2 到数据库中查找章节 Teachplan teachplan = teachplanMapper.selectById(id); //2.3 判断是否存在 if(teachplan!=null){ //2.4 存在直接更新 BeanUtils.copyProperties(saveTeachplanDto,teachplan); teachplanMapper.updateById(teachplan); return; } //2.5 不存在，即为添加 //先为teachplan创建空间 teachplan=new Teachplan(); BeanUtils.copyProperties(saveTeachplanDto,teachplan); //确定排序字段 Integer count = getTeachplanCount(saveTeachplanDto); teachplan.setOrderby(count+1); int insert = teachplanMapper.insert(teachplan); if(insert \u0026lt; 1){ XueChengPlusException.cast(\u0026#34;新增章节失败!\u0026#34;); } } /** * @description 获取最新的排序号 * @param courseId 课程id * @param parentId 父课程计划id * @return int 最新排序号 */ private int getTeachplanCount(long courseId,long parentId){ LambdaQueryWrapper\u0026lt;Teachplan\u0026gt; queryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(Teachplan::getCourseId,courseId); queryWrapper.eq(Teachplan::getParentid,parentId); Integer count = teachplanMapper.selectCount(queryWrapper); return count; } 接口测试 完善接口的代码 ，调用service方法完成课程计划的创建和修改。\n1 2 3 4 5 @ApiOperation(\u0026#34;课程计划创建或修改\u0026#34;) @PostMapping(\u0026#34;/teachplan\u0026#34;) public void saveTeachplan( @RequestBody SaveTeachplanDto teachplan){ teachplanService.saveTeachplan(teachplan); } 首先使用httpclient做以下测试。\n添加章\n1 2 3 4 5 6 7 8 9 10 ### 新增课程计划--章 POST {{content_host}}/content/teachplan Content-Type: application/json { \u0026#34;courseId\u0026#34; : 74, \u0026#34;parentid\u0026#34;: 0, \u0026#34;grade\u0026#34; : 1, \u0026#34;pname\u0026#34; : \u0026#34;新章名称 [点击修改]\u0026#34; } 添加小节\n1 2 3 4 5 6 7 8 9 10 ### 新增课程计划--节,从数据库找到第一级的课程计划id向其下边添加计划 POST {{content_host}}/content/teachplan Content-Type: application/json { \u0026#34;courseId\u0026#34; : 74, \u0026#34;parentid\u0026#34;: 247, \u0026#34;grade\u0026#34; : 2, \u0026#34;pname\u0026#34; : \u0026#34;小节名称 [点击修改]\u0026#34; } 保存课程计划\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ### 课程课程计划,需要从数据库找到修改的课程计划id POST {{content_host}}/content/teachplan Content-Type: application/json { \u0026#34;changeDate\u0026#34; : null, \u0026#34;courseId\u0026#34; : 22, \u0026#34;cousePubId\u0026#34; : null, \u0026#34;createDate\u0026#34; : null, \u0026#34;ctlBarShow\u0026#34; : false, \u0026#34;ctlEditTitle\u0026#34; : true, \u0026#34;endTime\u0026#34; : null, \u0026#34;grade\u0026#34; : \u0026#34;2\u0026#34;, \u0026#34;isPreview\u0026#34; : \u0026#34;1\u0026#34;, \u0026#34;mediaType\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;orderby\u0026#34; : 1, \u0026#34;parentid\u0026#34; : 237, \u0026#34;pname\u0026#34; : \u0026#34;第1节修改名称\u0026#34;, \u0026#34;startTime\u0026#34; : null, \u0026#34;status\u0026#34; : null, \u0026#34;teachPlanId\u0026#34; : 240 } 前后端联调\n分别联调新增章、新增小节、保存计划信息。 Bug修改 通过接口测试我们发现：\n使用httpclient测试没有问题\n前后端联调时发现新增的第一级目录不能显示在列表中。\n原因：这是因为在查询课程计划的时候，使用的sql语句在连接父节点和子节点采用的是内连接，内连接会省略没有子节点的父节点，而新增的章节恰恰是一个没有子节点的父节点，故其被省略了，所以我们要使用左外连接，使所有的父节点都要被显示。\n修改com/xuecheng/content/mapper/TeachplanMapper.xml如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;select id=\u0026#34;selectTreeNodes\u0026#34; resultMap=\u0026#34;treeNodeResultMap\u0026#34;\u0026gt; SELECT one.id one_id, one.pname one_pname, one.parentid one_parentid, one.grade one_grade, one.media_type one_mediaType, one.start_time one_startTime, one.end_time one_endTime, one.orderby one_orderby, one.course_id one_courseId, one.course_pub_id one_coursePubId, two.id two_id, two.pname two_pname, two.parentid two_parentid, two.grade two_grade, two.media_type two_mediaType, two.start_time two_startTime, two.end_time two_endTime, two.orderby two_orderby, two.course_id two_courseId, two.course_pub_id two_coursePubId, two.is_preview two_isPreview, m1.media_fileName mediaFilename, m1.id teachplanMeidaId, m1.media_id mediaId FROM teachplan one LEFT JOIN teachplan two ON two.parentid = one.id LEFT JOIN teachplan_media m1 ON two.id = m1.teachplan_id WHERE one.parentid = 0 AND one.course_id = #{courseId} ORDER BY one.orderby,two.orderby \u0026lt;/select\u0026gt; 3、思考添加课程计划的实现方式是否存在bug?\n存在bug，因为我们在确定新增小节或者章节的排序时，是用的count，即计算当前章节有多少个，然后再此基础+1为新的章节或小节的orderBy赋值，但是，前面的章节可能被删除过，所以当前的orderBy可能是：1、3、6这几个数，但是count只有3，所以新增章节的orderBy会被赋值为4，儿这是错误，所以我们需要得到orderBy的最大值，然后再赋值给新章节或小节的orderBy\n代码修改如下\n1 2 3 4 5 6 7 8 9 private Integer getTeachplanCount(SaveTeachplanDto saveTeachplanDto) { //查询当前orderBy最大值 LambdaQueryWrapper\u0026lt;Teachplan\u0026gt; queryWrapper=new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(Teachplan::getCourseId,saveTeachplanDto.getCourseId()) .eq(Teachplan::getParentid,saveTeachplanDto.getParentid()).orderByDesc(Teachplan::getOrderby) .last(\u0026#34;limit 1\u0026#34;); Teachplan teachplan = teachplanMapper.selectOne(queryWrapper); return teachplan.getOrderby(); } 删除课程计划 需求分析 业务流程 课程计划添加成功，如果课程还没有提交时可以删除课程计划。 删除第一级别的章时要求章下边没有小节方可删除。 删除第二级别的小节的同时需要将与其关联的视频信息也删除。 删除课程计划需要传输课程计划的id。 数据模型 删除课程计划接口需要用到课程计划数据表以及课程计划和课程计划与媒资的关系表\n课程计划表\n课程计划与媒资关系表\n接口定义 删除课程计划的接口示例如下：\n1 2 3 4 5 6 删除结点 Request URL: /content/teachplan/246 Request Method: DELETE 如果失败： {\u0026#34;errCode\u0026#34;:\u0026#34;120409\u0026#34;,\u0026#34;errMessage\u0026#34;:\u0026#34;课程计划信息还有子级信息，无法操作\u0026#34;} 如果成功：状态码200，不返回信息 根据上述的接口示例，接口定义如下：\n1 2 3 4 5 6 7 8 9 /** * 课程计划的删除 * @param id 课程计划id */ @DeleteMapping(\u0026#34;/teachplan/{id}\u0026#34;) @ApiOperation(\u0026#34;删除课程计划\u0026#34;) public void deleteTeachplan(@PathVariable(\u0026#34;id\u0026#34;) Long id){ teachplanService.deleteTeachplan(id); } 接口开发 Mapper层开发 mapper直接用代码生成器生成的即可。 Service层开发 定义删除课程计划的service接口 1 2 3 4 5 /** * 课程计划删除 * @param id 课程计划id */ void deleteTeachplan(Long id); 实现删除课程计划的service接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @Transactional @Override public void deleteTeachplan(Long id) { //1.根据课程计划id查询课程，判断课程是否存在 Teachplan teachplan = teachplanMapper.selectById(id); Long courseId = teachplan.getCourseId(); CourseBase courseBase = courseBaseMapper.selectById(courseId); if(courseBase==null){ XueChengPlusException.cast(\u0026#34;课程不存在\u0026#34;); } //2.课程已经发布不能删除课程计划 if (courseBase.getStatus().equals(\u0026#34;203002\u0026#34;)){ XueChengPlusException.cast(\u0026#34;课程已发布，无法删除\u0026#34;); } //3.删除章节是，要求该章节下没有小节 if(teachplan.getGrade()==1){ //查询是父节点为该课章节的个数 LambdaQueryWrapper\u0026lt;Teachplan\u0026gt; queryWrapper=new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(Teachplan::getParentid,id); int count = teachplanMapper.selectCount(queryWrapper); if(count\u0026gt;0){ XueChengPlusException.cast(\u0026#34;课程计划信息还有子级信息，无法操作\u0026#34;); } return; } //4.删除小节时，要求删除与其关联的视频信息 //4.1删除小节 int deleteTeachPlan = teachplanMapper.deleteById(id); if (deleteTeachPlan\u0026lt;1){ XueChengPlusException.cast(\u0026#34;删除课程小节失败\u0026#34;); } //4.2删除与其关联的媒资信息 if(teachplan.getMediaType()==null){ //无媒资信息，直接返回即可 return; } LambdaQueryWrapper\u0026lt;TeachplanMedia\u0026gt; queryWrapper=new LambdaQueryWrapper(); queryWrapper.eq(TeachplanMedia::getTeachplanId,id); int delete = teachplanMediaMapper.delete(queryWrapper); if(delete\u0026lt;1){ XueChengPlusException.cast(\u0026#34;删除小节的媒资信息失败\u0026#34;); } } 接口测试 使用HttpClient测试 1 2 ### 删除课程计划 DELETE {{content_host}}/content/teachplan/128 分以下几种情况测试：\n删除有子课程计划的计划 删除没有子课程计划的计划 前后端联调\n删除有子课程计划的计划\n删除没有子课程计划的计划\n可直接删除成功 课程计划排序 需求分析 课程计划新增后默认排在同级别最后，课程计划排序功能是可以灵活调整课程计划的显示顺序 业务流程 上移表示将课程计划向上移动。 下移表示将课程计划向下移动。 向上移动表示和上边的课程计划交换位置，将两个课程计划的排序字段值交换。 向下移动表示和下边的课程计划交换位置，将两个课程计划的排序字段值交换。 数据模型 课程计划排序用到课程计划表\n接口定义 示例接口如下：\n向下移动： 1 2 3 Request URL: http://localhost:8601/api/content/teachplan/movedown/43 Request Method: POST 43为课程计划id 向上移动 1 2 3 Request URL: http://localhost:8601/api/content/teachplan/moveup/43 Request Method: POST 43为课程计划id 每次移动传递两个参数：\n移动类型: movedown和moveup\n课程计划id:4\n接口定义如下：\n1 2 3 4 5 6 7 8 9 10 /** * 课程计划排序 * @param moveType * @param id */ @PostMapping(\u0026#34;/teachplan/{moveType}/{id}\u0026#34;) @ApiOperation(\u0026#34;课程计划排序\u0026#34;) public void moveTeachplan(@PathVariable(\u0026#34;moveType\u0026#34;) String moveType,@PathVariable(\u0026#34;id\u0026#34;) Long id){ teachplanService.moveTeachplan(moveType,id); } 接口开发 Mapper层开发 直接使用代码生成器的 Service层开发 定义课程计划排序的service接口 1 2 3 4 5 6 /** * 课程计划排序 * @param moveType * @param id */ void moveTeachplan(String moveType, Long id); 实现课程计划排序的service接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 @Override @Transactional public void moveTeachplan(String moveType, Long id) { //1.根据查询出当前课程计划 Teachplan teachplan = teachplanMapper.selectById(id); //2.根据该课程计划的parentId查询所有与其同级的课程计划(根据parentId和courseId) LambdaQueryWrapper\u0026lt;Teachplan\u0026gt; queryWrapper=new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(Teachplan::getParentid,teachplan.getParentid()) .eq(Teachplan::getCourseId,teachplan.getCourseId()) .orderByAsc(Teachplan::getOrderby); List\u0026lt;Teachplan\u0026gt; teachplans = teachplanMapper.selectList(queryWrapper); //2.判断时上移还是下移 if(moveType.equals(\u0026#34;movedown\u0026#34;)){ //下移 //2.1.判断是否为最后一级，如果是最后一级，则不允许下移 if(teachplan.equals(teachplans.get(teachplans.size()-1))){ XueChengPlusException.cast(\u0026#34;该课程计划为最后一级，不允许下移\u0026#34;); } //2.2.找到当前课程计划的位置 int index = getIndexFromList(teachplan, teachplans); if(index==-1){ //未知错误 XueChengPlusException.cast(CommonError.UNKOWN_ERROR); } //2.3.找到下一级的课程计划 Teachplan nextTeachplan = teachplans.get(index+1); //2.4.将两者的orderBy交换 int orderby = teachplan.getOrderby(); teachplan.setOrderby(nextTeachplan.getOrderby()); nextTeachplan.setOrderby(orderby); //2.5.最后将课程计划更新到数据库中 teachplanMapper.updateById(teachplan); teachplanMapper.updateById(nextTeachplan); //2.6直接返回 return; } //3.不是下移，是上移 //3.1.判断是否为第一级，如果是第一级，则不允许上移 if(teachplan.equals(teachplans.get(0))){ XueChengPlusException.cast(\u0026#34;该课程计划为第一级，不允许上移\u0026#34;); } //3.2.找到当前课程计划的位置 int index = getIndexFromList(teachplan, teachplans); if(index==-1){ //未知错误 XueChengPlusException.cast(CommonError.UNKOWN_ERROR); } //3.3.找到上一级的课程计划 Teachplan preTeachplan = teachplans.get(index-1); //3.4将两者的orderBy交换 int orderby = teachplan.getOrderby(); teachplan.setOrderby(preTeachplan.getOrderby()); preTeachplan.setOrderby(orderby); //3.5.最后将课程计划更新到数据库中 teachplanMapper.updateById(teachplan); teachplanMapper.updateById(preTeachplan); } /** * 获取课程计划在列表中的位置 * @param teachplan * @param teachplans * @return */ private int getIndexFromList(Teachplan teachplan, List\u0026lt;Teachplan\u0026gt; teachplans) { for (int i = 0; i \u0026lt; teachplans.size(); i++) { if(teachplan.equals(teachplans.get(i))){ return i; } } return -1; } 接口测试 直接前后端联调\n向上移动测试\n先找一个上边有课程计划的进行测试，向上移动后两个交换顺序。\n再找最上边的课程计划向上移动，应该没有反映才对，因为已经在最上边了。\n向下移动测试\n先找一个下边有课程计划的进行测试，向下移动后两个交换顺序。\n再找最下边的课程计划向下移动，应该没有反映才对，因为已经在最下边了。\n师资管理 需求分析 业务流程 课程计划界面点击下一步进入教师管理界面 点击添加教师打开添加界面，不用实现上传照片 添加成功查询教师信息 点击编辑，修改教师信息 点击删除，删除指定的教师信息。 [!CAUTION]\n注意：\n只允许向机构自己的课程中添加老师、删除老师。\n机构id统一使用：1232141425L\n数据模型 师资管理接口需要使用的数据表为课程-教师计划表\n接口定义 示例接口如下\n查询教师 1 2 3 4 5 6 7 8 9 10 11 12 13 14 get /courseTeacher/list/75 75为课程id，请求参数为课程id 响应结果 [ { \u0026#34;id\u0026#34;: 23, \u0026#34;courseId\u0026#34;: 75, \u0026#34;teacherName\u0026#34;: \u0026#34;张老师\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;讲师\u0026#34;, \u0026#34;introduction\u0026#34;: \u0026#34;张老师教师简介张老师教师简介张老师教师简介张老师教师简介\u0026#34;, \u0026#34;photograph\u0026#34;: null, \u0026#34;createDate\u0026#34;: null } ] 添加教师 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 post /courseTeacher 请求参数： { \u0026#34;courseId\u0026#34;: 75, \u0026#34;teacherName\u0026#34;: \u0026#34;王老师\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;教师职位\u0026#34;, \u0026#34;introduction\u0026#34;: \u0026#34;教师简介\u0026#34; } 响应结果： { \u0026#34;id\u0026#34;: 24, \u0026#34;courseId\u0026#34;: 75, \u0026#34;teacherName\u0026#34;: \u0026#34;王老师\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;教师职位\u0026#34;, \u0026#34;introduction\u0026#34;: \u0026#34;教师简介\u0026#34;, \u0026#34;photograph\u0026#34;: null, \u0026#34;createDate\u0026#34;: null } 修改教师 1 2 3 4 5 6 7 8 9 10 11 12 13 14 post /courseTeacher 请求参数： { \u0026#34;id\u0026#34;: 24, \u0026#34;courseId\u0026#34;: 75, \u0026#34;teacherName\u0026#34;: \u0026#34;王老师\u0026#34;, \u0026#34;position\u0026#34;: \u0026#34;教师职位\u0026#34;, \u0026#34;introduction\u0026#34;: \u0026#34;教师简介\u0026#34;, \u0026#34;photograph\u0026#34;: null, \u0026#34;createDate\u0026#34;: null } 响应： {\u0026#34;id\u0026#34;:24,\u0026#34;courseId\u0026#34;:75,\u0026#34;teacherName\u0026#34;:\u0026#34;王老师\u0026#34;,\u0026#34;position\u0026#34;:\u0026#34;教师职 位\u0026#34;,\u0026#34;introduction\u0026#34;:\u0026#34;教师简介\u0026#34;,\u0026#34;photograph\u0026#34;:null,\u0026#34;createDate\u0026#34;:null} 删除教师 1 2 3 4 5 delete /ourseTeacher/course/75/26 75:课程id 26:教师id，即course_teacher表的主键 请求参数：课程id、教师id 响应：状态码200，不返回信息 接口定义如下\n查询教师 1 2 3 4 5 6 7 8 9 10 /** * 根据课程id查询教师列表 * @param courseId * @return */ @GetMapping(\u0026#34;/list/{courseId}\u0026#34;) @ApiOperation(\u0026#34;查询教师接口\u0026#34;) public List\u0026lt;CourseTeacher\u0026gt; getCourseTeacherList(@PathVariable(\u0026#34;courseId\u0026#34;) Long courseId) { return courseTeacherService.getCourseTeacherList(courseId); } 添加教师 1 2 3 4 5 6 7 8 9 10 11 12 /** * 添加或修改教师 * @param courseTeacher * @return */ @PostMapping @ApiOperation(\u0026#34;添加或修改教师接口\u0026#34;) public CourseTeacher addCourseTeacher(@RequestBody @Validated(ValidationGroups.Insert.class) CourseTeacher courseTeacher) { //TODO 获取机构id Long companyId = 1232141425L; return courseTeacherService.saveCourseTeacher(companyId,courseTeacher); } 修改教师 1 2 3 4 5 6 7 8 9 10 11 12 /** * 添加或修改教师 * @param courseTeacher * @return */ @PostMapping @ApiOperation(\u0026#34;添加或修改教师接口\u0026#34;) public CourseTeacher addCourseTeacher(@RequestBody @Validated(ValidationGroups.Insert.class) CourseTeacher courseTeacher) { //TODO 获取机构id Long companyId = 1232141425L; return courseTeacherService.saveCourseTeacher(companyId,courseTeacher); } 删除教师 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * 删除教师接口 * @param courseId * @param teacherId */ @DeleteMapping(\u0026#34;course/{courseId}/{courseTeacherId}\u0026#34;) @ApiOperation(\u0026#34;删除教师接口\u0026#34;) public void deleteCourseTeacher(@PathVariable(\u0026#34;courseId\u0026#34;) Long courseId, @PathVariable(\u0026#34;courseTeacherId\u0026#34;) Long teacherId) { //TODO 获取机构id Long companyId = 1232141425L; courseTeacherService.deleteCourseTeacher(companyId,courseId, teacherId); } 接口开发 Mapper层开发 直接使用代码生成器的 Service层开发 Service接口定义 定义查询教资的service接口 1 2 3 4 5 6 /** * 根据课程id查询教师列表 * @param courseId * @return */ List\u0026lt;CourseTeacher\u0026gt; getCourseTeacherList(Long courseId); 定义增加或修改教资的service接口 1 2 3 4 5 6 7 /** * 添加或修改教师 * @param companyId * @param courseTeacher * @return */ CourseTeacher saveCourseTeacher(Long companyId, CourseTeacher courseTeacher); 定义删除教资的service接口 1 2 3 4 5 6 /** * 删除教师 * @param courseId * @param teacherId */ void deleteCourseTeacher(Long companyId,Long courseId, Long teacherId); Service接口实现 实现查询教资的service接口 1 2 3 4 5 6 7 @Override public List\u0026lt;CourseTeacher\u0026gt; getCourseTeacherList(Long courseId) { //1.根据课程id查询老师列表 LambdaQueryWrapper\u0026lt;CourseTeacher\u0026gt; queryWrapper=new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(CourseTeacher::getCourseId,courseId); return courseTeacherMapper.selectList(queryWrapper); } 实现增加或修改教资的service接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @Override public CourseTeacher saveCourseTeacher(Long companyId, CourseTeacher courseTeacher) { //1.业务逻辑校验，只允许向机构自己的课程中添加或修改老师 checkCompanyId(companyId, courseTeacher.getCourseId()); //2.判断是否已经存在 LambdaQueryWrapper\u0026lt;CourseTeacher\u0026gt; queryWrapper=new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(CourseTeacher::getId,courseTeacher.getId()); CourseTeacher courseTeacherOld = courseTeacherMapper.selectOne(queryWrapper); if (courseTeacherOld!=null){ //2.1已经存在，修改师资信息 int update = courseTeacherMapper.updateById(courseTeacher); //2.2.判断是否修改成功 if(update\u0026lt; 1){ XueChengPlusException.cast(\u0026#34;修改教师信息失败\u0026#34;); } return courseTeacher; } //3不存在，添加师资信息 //3.1course_id和teacher_name不能同时相等 //即一个老师不能重复的与一个课程对应 queryWrapper=new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(CourseTeacher::getCourseId,courseTeacher.getCourseId()) .eq(CourseTeacher::getTeacherName,courseTeacher.getTeacherName()); CourseTeacher teacher = courseTeacherMapper.selectOne(queryWrapper); if(teacher!=null){ XueChengPlusException.cast(\u0026#34;该老师已添加\u0026#34;); } //3.2设置创建时间 courseTeacher.setCreateDate(LocalDateTime.now()); //3.3添加师资信息 int insert = courseTeacherMapper.insert(courseTeacher); //3.4.判断是否插入成功 if(insert\u0026lt; 1){ XueChengPlusException.cast(\u0026#34;添加教师信息失败\u0026#34;); } //4.返回添加的课程老师对象 return courseTeacher; } private void checkCompanyId(Long companyId, Long courseId) { //1.2根据课程id查询课程 CourseBase courseBase = courseBaseMapper.selectById(courseId); //1.3判断课程是否属于本机构 if(!companyId.equals(courseBase.getCompanyId())){ XueChengPlusException.cast(\u0026#34;本机构只能变更本机构的课程\u0026#34;); } } 实现删除教资的service接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private void checkCompanyId(Long companyId, Long courseId) { //1.2根据课程id查询课程 CourseBase courseBase = courseBaseMapper.selectById(courseId); //1.3判断课程是否属于本机构 if(!companyId.equals(courseBase.getCompanyId())){ XueChengPlusException.cast(\u0026#34;本机构只能变更本机构的课程\u0026#34;); } } @Override public void deleteCourseTeacher(Long companyId,Long courseId, Long teacherId) { //1.业务逻辑校验，只允许向机构自己的课程中删除老师 checkCompanyId(companyId, courseId); //2.删除 LambdaQueryWrapper\u0026lt;CourseTeacher\u0026gt; queryWrapper=new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(CourseTeacher::getId,teacherId) .eq(CourseTeacher::getCourseId,courseId); int delete = courseTeacherMapper.delete(queryWrapper); //2.1判断是否删除成功 if(delete\u0026lt; 1){ XueChengPlusException.cast(\u0026#34;删除教师信息失败\u0026#34;); } } 接口测试 直接前后端联调即可 删除课程 需求分析 业务流程 课程的审核状态为未提交时方可删除。 删除课程需要删除课程相关的基本信息、营销信息、课程计划、课程教师信息。 数据模型 删除课程需要使用的表有：课程基本信息表，课程营销表，课程计划表，课程计划与媒资的关系表，课程教师信息表 接口定义 删除课程接口 1 2 3 4 delete /course/87 87为课程id 请求参数：课程id 响应：状态码200，不返回信息 删除课程接口定义 1 2 3 4 5 6 7 8 9 10 11 /** * 删除课程 * @param courseId 要删除的课程id */ @ApiOperation(\u0026#34;删除课程\u0026#34;) @DeleteMapping(\u0026#34;/course/{courseId}\u0026#34;) public void deleteCourseBase(@PathVariable(\u0026#34;courseId\u0026#34;) Long courseId){ //TODO 获取机构id Long companyId=1232141425L; courseBaseService.deleteCourseBase(companyId,courseId); } 接口开发 Mapper层开发 使用代码生成器的即可 Service层开发 定义删除课程service接口 1 2 3 4 5 /** * 删除课程 * @param courseId */ void deleteCourseBase(Long companyId,Long courseId); 实现删除课程service接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /** * 校验本机构只能变更本机构的课程 * @param companyId * @param courseId */ private void checkCompanyId(Long companyId,Long courseId) { CourseBase courseBase = courseBaseMapper.selectById(courseId); if(!companyId.equals(courseBase.getCompanyId())){ XueChengPlusException.cast(\u0026#34;本机构只能变更本机构的课程\u0026#34;); } } @Override @Transactional public void deleteCourseBase(Long companyId,Long courseId) { //本机构只能删除本机构的课程 checkCompanyId(companyId,courseId); //1.课程的审核状态为未提交时方可删除。 //1.1根据课程id查询课程基本信息 CourseBase courseBase = courseBaseMapper.selectById(courseId); if(courseBase==null){ XueChengPlusException.cast(\u0026#34;课程不存在\u0026#34;); } if(!\u0026#34;202002\u0026#34;.equals(courseBase.getAuditStatus())){ XueChengPlusException.cast(\u0026#34;课程的审核状态为未提交时方可删除。\u0026#34;); } //2 删除课程信息 //2.1删除课程基本信息 int delete1 = courseBaseMapper.deleteById(courseId); if(delete1\u0026lt;1){ XueChengPlusException.cast(\u0026#34;删除课程基本信息失败\u0026#34;); } //2.2删除课程营销信息 int delete2 = courseMarketMapper.deleteById(courseId); //2.3删除课程计划信息 LambdaQueryWrapper\u0026lt;Teachplan\u0026gt; queryWrapper1=new LambdaQueryWrapper(); queryWrapper1.eq(Teachplan::getCourseId,courseId); int delete3 = teachplanMapper.delete(queryWrapper1); //2.4删除课程媒资信息 LambdaQueryWrapper\u0026lt;TeachplanMedia\u0026gt; queryWrapper2=new LambdaQueryWrapper(); queryWrapper2.eq(TeachplanMedia::getTeachplanId,courseId); int delete4 = teachplanMediaMapper.delete(queryWrapper2); //2.5 删除课程教师信息 LambdaQueryWrapper\u0026lt;CourseTeacher\u0026gt; queryWrapper3=new LambdaQueryWrapper(); queryWrapper3.eq(CourseTeacher::getCourseId,courseId); int delete5 = courseTeacherMapper.delete(queryWrapper3); } 接口测试 直接前后端联调即可 ","date":"2024-10-04T00:00:00Z","image":"https://lazman-ll.github.io/p/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/zaixianjiaoyu_hu15330337887880486241.jpg","permalink":"https://lazman-ll.github.io/p/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97/","title":"学成在线内容管理模块"},{"content":"本文描述了黑马springcloud项目学成在线的环境搭建过程\n1 开发工具版本 本项目主要使用的开发工具列表如下所示：\n开发工具 版本号 安装位置 IntelliJ-IDEA 2021.x以上版本 个人电脑 JDK 1.8.x 个人电脑 Maven 3.8.x以上版本 个人电脑 Git 2.37.x 个人电脑 VMware-workstation 16.x 个人电脑 CentOS 7.x 虚拟机 Docker 18.09.0 虚拟机 Mysql 8.x docker nacos 1.4.1 docker rabbitmq 3.8.34 docker redis 6.2.7 docker xxl-job-admin 2.3.1 docker minio RELEASE.2022-09-07 docker elasticsearch 7.12.1 docker kibana 7.12.1 docker gogs 0.13.0 docker nginx 1.12.2 docker 2 IDEA 环境配置 2.1 创建GitHub仓库 2.2 在IDEA中拉取GitHub中的仓库 创建项目时，选择通过版本控制创建项目(Get from VCS)\n输入仓库地址，并选择工程路径。\n2.3 编码配置 2.4 设置Java编译级别 本项目使用jdk8作为项目语言环境，故需要设置Java的编译环境：\n工程创建成功后，点击Project Structure：\n点击Project，设置SDK为1.8及Project language level，如下图：\n3 Maven 环境 3.1 配置maven仓库 解压课程资料中的maven仓库下的repository.zip到你的maven工作目录(或者随便一个目录)中\n在maven的conf目录中的setting.xml文件中配置本地仓库的地址，为刚才repository.zip的地址\n​\t3.2 IDEA中配置maven 在IDEA中配置maven：进入 File \u0026ndash;\u0026gt; Settings \u0026ndash;\u0026gt; Build \u0026ndash;\u0026gt; Build Tools \u0026ndash;\u0026gt; Maven，配置maven安装目录、setting.xml及本地仓库的位置。\n​\t①代表你的maven安装的位置，若以前用过maven，一般不用修改\n②代表你的maven的配置文件所在地址\n③代表你使用的本地仓库的地址(注意：最后一级目录是你所有依赖的前一级)\n4 安装虚拟机 项目中用到的一些服务端软件如：MySQL、Nacos配置中心、RabbitMQ消息队列等通常会安装在企业局域网的服务器中，开发人员去远程连接它们。在本项目中我们在自己的电脑上安装虚拟机，虚拟机代表了企业局域网中的服务器。\n服务器操作系统使用Centos7，导入黑马课程中的虚拟机文件(包含了所有的需要安装的服务端软件)，也可以自行安装Centos7虚拟机(服务端软件需要自己安装)。\n4.1 设置虚拟机网络 点击 “编辑\u0026ndash;》虚拟网络编辑器”配置网络地址，地址须与下图一致。\n设置子网IP：192.168.101.0，子网掩码：255.255.255.0。\n4.2 导入虚拟机 解压课程资料中的虚拟机文件，进入解压后的文件夹，双击\u0026quot;CentOS 7 64 位.vmx\u0026quot; 文件，选择复制虚拟机。(博主在实操过程中并未出现复制虚拟机选项，而是直接跳转到了vm界面中，但是在开启该虚拟机时，有一个选项要求我选择\u0026quot;已复制虚拟机\u0026quot;或\u0026quot;已移动虚拟机\u0026quot;，我选择了已复制，此处不知是否有问题？)\n注意：虚拟机的IP地址为192.168.101.65，不用修改IP地址。\n4.3 远程连接虚拟机 博主使用了MobaXterm 远程连接虚拟机中的CentOs系统，具体连接过程可自行上网搜索\nIP地址：192.168.101.65\n账号与密码为：root/centos\n连接完毕执行以下命令\n执行 systemctl start docker 启动docker。\n运行： sh /data/soft/restart.sh\n查询docker容器：docker ps，执行完毕后，docker容器运行情况如下图：\n​\t4.3 数据库客户端连接虚拟机中的MySQL 博主使用的Navicat进行连接\n所有数据库信息如下：其中包含了本项目所有要用的数据库，一般以后无需创建\n​\t5 Git环境配置 5.1 添加.gitignore文件 ​\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 HELP.md target/ !.mvn/wrapper/maven-wrapper.jar !**/src/main/** !**/src/test/** ### STS ### .apt_generated .classpath .factorypath .project .settings .springBeans .sts4-cache ### IntelliJ IDEA ### .idea *.iws *.iml *.ipr ### NetBeans ### /nbproject/private/ /nbbuild/ /dist/ /nbdist/ /.nb-gradle/ build/ logs/ ### VS Code ### .vscode/ 提交到git仓库当中\n5.2 创建开发分支 通常不会在主分支进行开发，本项目在dev开发分支进行开发(每一章节一个)，下边创建开发分支。\n新建一个分支，点击IDEA右下角的分支标识：\n输入分支名称：\n​\t点击create即创建成功，打卡Git log，其中标识了小铅笔的就是当前分支\n然后将分支push到github上即可\n6 基础工程搭建 6.1 工程结构关系 学成在线使用 Maven 来进行项目的管理和构建。整个项目分为三大类工程：父工程、基础工程 和微服务工程。\n​\t每一种类的工程都有不同的作用，下面时对其功能进行说明：\n父工程\n对依赖包的版本进行管理\n本身为Pom工程，对子工程进行聚合管理\n基础工程\n继承父类工程\n提供基础类库\n提供工具类库\n微服务工程\n分别从业务、技术方面划分模块，每个模块构建为一个微服务。\n每个微服务工程依赖基础工程，间接继承父工程。\n包括：内容管理服务、媒资管理服务、搜索服务、订单支付服务等。\n6.2 构建父工程 父工程的职责是对依赖包的版本进行管理，本小节创建父工程分两步，第一创建父工程，第二在pom.xml编辑依赖管理。\n首先创建父工程，为了对代码更好的进行权限管理，这里我们单独创建父工程。选择Spring Initalizr，填写模块信息：\n模块名：xuecheng-plus-parent\n包名：com.xuecheng\n依赖管理定义\n下边开始编辑xuecheng-plus-parent父工程的依赖管理 。\n父工程中没有代码，不用去依赖其它的包，它的作用是限定其它子工程依赖包的版本号，即在dependencyManagement 中去编辑即可。\n确定父工程为一个pom工程，在pom.xml中添加如下内容：\n\u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt;\n编辑依赖的包的版本号、打包插件等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;xuecheng-plus-parent\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;xuecheng-plus-parent\u0026lt;/description\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;2.3.7.RELEASE\u0026lt;/spring-boot.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;Hoxton.SR9\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;org.mapstruct.version\u0026gt;1.3.1.Final\u0026lt;/org.mapstruct.version\u0026gt; \u0026lt;spring-cloud-alibaba.version\u0026gt;2.2.6.RELEASE\u0026lt;/spring-cloud-alibaba.version\u0026gt; \u0026lt;org.projectlombok.version\u0026gt;1.18.8\u0026lt;/org.projectlombok.version\u0026gt; \u0026lt;javax.servlet-api.version\u0026gt;4.0.1\u0026lt;/javax.servlet-api.version\u0026gt; \u0026lt;fastjson.version\u0026gt;1.2.83\u0026lt;/fastjson.version\u0026gt; \u0026lt;druid-spring-boot-starter.version\u0026gt;1.2.8\u0026lt;/druid-spring-boot-starter.version\u0026gt; \u0026lt;mysql-connector-java.version\u0026gt;8.0.30\u0026lt;/mysql-connector-java.version\u0026gt; \u0026lt;mybatis-plus-boot-starter.version\u0026gt;3.4.1\u0026lt;/mybatis-plus-boot-starter.version\u0026gt; \u0026lt;commons-lang.version\u0026gt;2.6\u0026lt;/commons-lang.version\u0026gt; \u0026lt;minio.version\u0026gt;8.4.3\u0026lt;/minio.version\u0026gt; \u0026lt;xxl-job-core.version\u0026gt;2.3.1\u0026lt;/xxl-job-core.version\u0026gt; \u0026lt;swagger-annotations.version\u0026gt;1.5.20\u0026lt;/swagger-annotations.version\u0026gt; \u0026lt;commons-lang3.version\u0026gt;3.10\u0026lt;/commons-lang3.version\u0026gt; \u0026lt;okhttp.version\u0026gt;4.8.1\u0026lt;/okhttp.version\u0026gt; \u0026lt;swagger-spring-boot-starter.version\u0026gt;1.9.0.RELEASE\u0026lt;/swagger-spring-boot-starter.version\u0026gt; \u0026lt;elasticsearch.version\u0026gt;7.12.1\u0026lt;/elasticsearch.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud-alibaba.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- lombok，简化类的构建--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.projectlombok.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mapstruct 代码生成器，简化java bean之间的映射 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct-jdk8\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.mapstruct.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct-processor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.mapstruct.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.swagger\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;swagger-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${swagger-annotations.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Servlet 容器管理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${javax.servlet-api.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- fastjson ，json解析工具 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${fastjson.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- druid 连接池管理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${druid-spring-boot-starter.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mySQL数据库驱动包管理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql-connector-java.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis plus 集成Spring Boot启动器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus-boot-starter.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- mybatis plus 代码生成器 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-generator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-plus-boot-starter.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 工具类管理 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-lang\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${commons-lang.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 分布式文件系统 minIO的客户端API包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.minio\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;minio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${minio.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--google推荐的一套工具类库--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.guava\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;guava\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;25.0-jre\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--分布式任务调度--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.xuxueli\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xxl-job-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${xxl-job-core.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Spring boot单元测试--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.vintage\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-vintage-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.squareup.okhttp3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${okhttp.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${commons-lang3.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.spring4all\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;swagger-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${swagger-spring-boot-starter.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.elasticsearch.client\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;elasticsearch-rest-high-level-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${elasticsearch.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.elasticsearch\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;elasticsearch\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${elasticsearch.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;${project.name}\u0026lt;/finalName\u0026gt; \u0026lt;!--编译打包过虑配置--\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--指定项目源码jdk的版本--\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;!--指定项目编译后的jdk的版本--\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;!--配置注解预编译--\u0026gt; \u0026lt;annotationProcessorPaths\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.projectlombok.version}\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/annotationProcessorPaths\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!--责处理项目资源文件并拷贝到输出目录，如果有额外的资源文件目录则需要配置--\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-resources-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;encoding\u0026gt;utf-8\u0026lt;/encoding\u0026gt; \u0026lt;!--使用默认分隔符，resource中可以使用分割符定义过虑的路径--\u0026gt; \u0026lt;useDefaultDelimiters\u0026gt;true\u0026lt;/useDefaultDelimiters\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 6.3 构建基础工程 基础工程的职责是提供一些系统架构所需要的基础类库以及一此工具类库。\n首先创建基础工程xuecheng-plus-base。创建的过程同父工程的创建过程，选择Spring Initalizr，填写模块信息：\n模块名：xuecheng-plus-base 包名：com.xuecheng 修改pom.xml文件\n这里需要注意的是xuecheng-plus-base的父工程为xuecheng-plus-parent，xuecheng-plus-base的pom.xml的如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.xuecheng\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../xuecheng-plus-parent\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;xuecheng-plus-base\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- fast Json --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- servlet Api 依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 通用组件 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-lang\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-codec\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-codec\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.swagger\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;swagger-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-validation\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--根据扩展名取mimetype--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.j256.simplemagic\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;simplemagic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.zxing\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.google.zxing\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javase\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.module\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-module-parameter-names\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.datatype\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-datatype-jdk8\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.datatype\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-datatype-jsr310\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 最后将父工程和基础工程提交到git上即可。\n","date":"2024-10-02T00:00:00Z","image":"https://lazman-ll.github.io/p/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/zaixianjiaoyu_hu15330337887880486241.jpg","permalink":"https://lazman-ll.github.io/p/%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"学成在线环境搭建"},{"content":"本博客使用了Hugo+Github的方法进行博客搭建，博客的搭建日期为2024-10-01，本文首次更新日期为2024-10-01，下面将详细介绍本博客的搭建方法。\nHugo的搭建 1.1 hugo的下载 进入Hugo下载地址网址选择最新的版本，当前最新版本为：v0.135.0，点击进入\nwindows环境：选择 hugo_extended_0.135.0_windows-amd64.zip，进行下载，并解压。\n1.2 创建博客 在解压后得到的文件的目录下进入命令行窗口，输入hugo new site xxxx（xxxx写文件的名字，自己取即可）以创建hugo文件\n将解压得到的hugo.exe复制到创建好的hugo文件中，然后输入cd xxxx 切换目录\n1.3 配置主题 前往Hugo Themes，挑选喜欢的主图，进行下载，这里我选用了stack主题\n以Stack主题为例，将下载好的主题解压，放到xxxx/themes文件夹下\n将exampleSite文件夹下的content文件夹以及hugo.yaml文件，复制到主文件夹下(即前面的xxxx，后面都为主文件夹)，并删除掉hugo.toml和content/post/rich-content\n修改hugo.yaml中的theme配置，将其修改为与主题的文件夹名一致，或者反过来修改主题文件夹名，只要保证两者一致即可。\n在命令行中键入hugo server -D，启动hugo服务，查看主题，具体的主题配置修改hugo.yaml即可，详情可看 Hugo 主题 Stack (中文)(非官方)或者Hugo 主题 Stack(官方)\nGithub搭建 此处需要git和GitHub账号，可自行在网上查找如何配置\n2.1 静态界面部署 进入GitHub，创建仓库**{github用户名}.github.io**，并设置为public\n前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启https://{github用户名}.github.io的地址，该地址即博客地址\n修改hugo.yaml的baseurl为https://{github用户名}.github.io\n在主文件夹下进入命令行，键入huge -D，会生成public静态资源文件夹\n在public下进入命令行，依次执行如下命令，将资源上传到Github中，下面的命令在你的Github创建成功仓库的界面有，直接复制即可(第二条命令要与下面的一致)\n1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 上传成功后即可访问https://{github用户名}.github.io，查看自己的博客\n2.2 hugo部署(实现Github Action自动部署) 在Github中创建一个新的仓库，存放hugo主文件，此处设置为private即可\n前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic)，有效期选择永久，(否则失效后需要重新配置，但是若为了安全，可以自行选择)，勾选repo和workflow，创建。\n将生成的token，保存在仓库的变量中，进入刚刚创建的仓库，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置\n在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看Github Action文档\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy 在hugo主文件创建.gitignore文件，来避免提交不必要的文件\n将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面\n1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 以后修改了文件后就无需输入上述这么多命令，在主文件夹下进入命令行，输入如下命令即可，有时候git push失败可以多试几次\n1 2 3 git add . git commit -m \u0026#34;update\u0026#34; git push ","date":"2024-10-01T00:00:00Z","image":"https://lazman-ll.github.io/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/github-hugo_hu12902404653766232079.png","permalink":"https://lazman-ll.github.io/p/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"博客搭建"}]